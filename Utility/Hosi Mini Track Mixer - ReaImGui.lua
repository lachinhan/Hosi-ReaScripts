--[[
@description    Hosi Mini Track Mixer (ReaImGui Version)
@author         Hosi
@version        1.4
@reaper_version 6.0
@provides
  [main] . > Hosi_Mini Track Mixer (ReaImGui).lua

@about
  # Hosi Mini Track Mixer (ReaImGui Version)

  A small GUI workflow for mixing track volume, pan, width, sends, receives, and FX.

  ## Requirements:
  - REAPER 6.0+
  - js_ReaScriptAPI extension
  - ReaImGui library

@changelog
  v1.4 (2025-10-14)
  - Added: "Sync View" checkbox to synchronize the script's track filter with REAPER's main track view (TCP/Mixer).
  - Added: When Sync View is active, changing the view mode dropdown will automatically show/hide tracks in the project.
  - Added: Disabling Sync View will reset and show all tracks in the project.
  - Added: Display of the formatted parameter value (e.g., "-12.5 dB") next to each slider in FX PARAMS mode for precise control.
  - Improved: Replaced the static "VIEW" button in SENDS, RECEIVES, and FX PARAMS modes with the persistent View Mode dropdown filter.
  - Improved: The View Mode filter now applies to all editing modes for a more consistent workflow.
  - Added: FX Parameter Control mode. Users can now pin specific plugin parameters to the mixer for direct control.
  - Added: "Pin" button on each track to open a parameter selection window.
  - Added: Track Receives control mode, allowing users to view and manage all incoming signals for a selected track.
  - Added: Track Sends control mode. In this mode, the mixer displays tracks with sends, allowing detailed control over each send's volume, pan, and mute.
  v1.3 (2025-10-13)
  - Added: New View Modes: "SELECTED & CHILDREN", "ARMED", "HAS FX", "HAS ITEMS", "MUTED".
  - Added: Stereo Width control. The mode button now cycles through PAN, VOL, and WIDTH.
  - Added: Phase Invert button (Ã¸) for each track.
  - Improved: Replaced "Gang" checkbox with selection-based ganging.
  - Added: Track visibility control and toolbar buttons.
  v1.2 (2025-09-23)
  - Added: Right-click context menu.
  v1.1 (2025-09-23)
  - Added: Double-click to collapse/expand folders.
  v1.0 (2025-09-23)
  - Initial release.
--]]
local config = { win_title = "Hosi Mini Track Mixer v1.4", refresh_interval = 0.05, indent_size = 15.0 } package.path = reaper.ImGui_GetBuiltinPath() .. '/?.lua;' .. package.path local imgui = require('imgui')('0.10') if not imgui or type(imgui) ~= "table" then reaper.ShowMessageBox("Could not initialize ReaImGui library.\n\nPlease install it (v0.10+) via ReaPack.", "ReaImGui Error", 0) return end local ctx = imgui.CreateContext(config.win_title) local new_view_modes = { "ALL", "FOLDERS", "FOLDERS & CHILDREN", "SELECTED", "SELECTED & CHILDREN", "ARMED", "HAS FX", "HAS ITEMS", "MUTED" } local state = { is_open = true, edit_mode = "PAN", view_mode = 1, view_mode_names = new_view_modes, view_mode_names_str = table.concat(new_view_modes, "\0") .. "\0", filter_text = "", sync_view = false, tracks = {}, tracksPan = {}, tracksVol = {}, tracksWidth = {}, tracksSel = {}, tracksMut = {}, tracksSol = {}, tracksFX = {}, tracksFXCount = {}, tracksArmed = {}, tracksHasItems = {}, tracksDepth = {}, isFolder = {}, folderCollapsed = {}, tracksVisible = {}, tracksPhase = {}, tracksSends = {}, tracksReceives = {}, sends_view_track_idx = nil, receives_view_track_idx = nil, pinnedParams = {}, popup_pin_track_idx = nil, open_pin_popup = false, preset1 = { track = {} }, preset2 = { track = {} }, preset3 = { track = {} }, preset4 = { track = {} }, preset5 = { track = {} } } function PackColor(r, g, b, a) local r_int = math.floor(r * 255 + 0.5) local g_int = math.floor(g * 255 + 0.5) local b_int = math.floor(b * 255 + 0.5) local a_int = math.floor(a * 255 + 0.5) return a_int * 0x1000000 + b_int * 0x10000 + g_int * 0x100 + r_int end function GainToDB(gain) if gain < 0.0000000298 then return -144.0 end return 20 * (math.log(gain) / math.log(10)) end function DBToGain(db) return 10 ^ (db / 20) end function ForceUIRefresh() reaper.TrackList_AdjustWindows(false) reaper.UpdateArrange() end function save_pinned_params() local data_parts = {} for guid, pins in pairs(state.pinnedParams) do if pins and #pins > 0 then local pin_parts = {} for _, pin in ipairs(pins) do table.insert(pin_parts, pin.fx_idx .. "," .. pin.param_idx) end table.insert(data_parts, guid .. ":" .. table.concat(pin_parts, ";")) end end local data_string = table.concat(data_parts, "|") reaper.SetProjExtState(0, "Hosi.MiniTrackMixer", "Pins", data_string) end function load_pinned_params() local _, data_string = reaper.GetProjExtState(0, "Hosi.MiniTrackMixer", "Pins") state.pinnedParams = {} if data_string and data_string ~= "" then for track_data in string.gmatch(data_string, "([^|]+)") do local guid, pins_str = string.match(track_data, "([^:]+):([^:]+)") if guid and pins_str then state.pinnedParams[guid] = {} for pin_data in string.gmatch(pins_str, "([^;]+)") do local fx_idx, param_idx = string.match(pin_data, "([^,]+),([^,]+)") if fx_idx and param_idx then table.insert(state.pinnedParams[guid], { fx_idx = tonumber(fx_idx), param_idx = tonumber(param_idx) }) end end end end end end function ApplyViewFilter(i) local track = state.tracks[i] local show_track = true local current_view_mode = state.view_mode_names[state.view_mode] if current_view_mode == "FOLDERS" then if not state.isFolder[i] then show_track = false end elseif current_view_mode == "FOLDERS & CHILDREN" then if not state.isFolder[i] and state.tracksDepth[i] == 0 then show_track = false end elseif current_view_mode == "SELECTED" then if not state.tracksSel[i] then show_track = false end elseif current_view_mode == "SELECTED & CHILDREN" then local is_visible = state.tracksSel[i] if not is_visible then local parent = reaper.GetParentTrack(track) while parent do if reaper.IsTrackSelected(parent) then is_visible = true break end parent = reaper.GetParentTrack(parent) end end if not is_visible then show_track = false end elseif current_view_mode == "ARMED" then if not state.tracksArmed[i] then show_track = false end elseif current_view_mode == "HAS FX" then if state.tracksFXCount[i] < 1 then show_track = false end elseif current_view_mode == "HAS ITEMS" then if not state.tracksHasItems[i] then show_track = false end elseif current_view_mode == "MUTED" then if state.tracksMut[i] ~= 1 then show_track = false end end return show_track end function SyncTrackVisibility() reaper.Undo_BeginBlock() reaper.PreventUIRefresh(1) for i = 1, #state.tracks do local guid_str = reaper.GetTrackGUID(state.tracks[i]) local should_show = ApplyViewFilter(i) if state.edit_mode == "SENDS" and #state.tracksSends[i] == 0 then should_show = false elseif state.edit_mode == "RECEIVES" and #state.tracksReceives[i] == 0 then should_show = false elseif state.edit_mode == "FX PARAMS" and (not state.pinnedParams[guid_str] or #state.pinnedParams[guid_str] == 0) then should_show = false end local new_vis_state = should_show and 1 or 0 reaper.SetMediaTrackInfo_Value(state.tracks[i], "B_SHOWINTCP", new_vis_state) reaper.SetMediaTrackInfo_Value(state.tracks[i], "B_SHOWINMIXER", new_vis_state) end reaper.PreventUIRefresh(-1) reaper.Undo_EndBlock("Sync Track Visibility", -1) ForceUIRefresh() end function ResetAllTracksVisibility() reaper.Undo_BeginBlock() reaper.PreventUIRefresh(1) for i = 1, #state.tracks do reaper.SetMediaTrackInfo_Value(state.tracks[i], "B_SHOWINTCP", 1) reaper.SetMediaTrackInfo_Value(state.tracks[i], "B_SHOWINMIXER", 1) end reaper.PreventUIRefresh(-1) reaper.Undo_EndBlock("Show All Tracks", -1) ForceUIRefresh() end function update_and_check_tracks() local new_track_count = reaper.CountTracks(0) if #state.tracks ~= new_track_count then state.tracks, state.tracksPan, state.tracksVol, state.tracksWidth, state.tracksSel, state.tracksDepth, state.isFolder, state.folderCollapsed, state.tracksVisible, state.tracksPhase, state.tracksArmed, state.tracksHasItems, state.tracksFXCount, state.tracksSends, state.tracksReceives = {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} end for i = 1, new_track_count do local track = reaper.GetTrack(0, i - 1) state.tracks[i] = track state.tracksPan[i] = reaper.GetMediaTrackInfo_Value(track, "D_PAN") state.tracksVol[i] = reaper.GetMediaTrackInfo_Value(track, "D_VOL") state.tracksWidth[i] = reaper.GetMediaTrackInfo_Value(track, "D_WIDTH") state.tracksMut[i] = reaper.GetMediaTrackInfo_Value(track, "B_MUTE") state.tracksSol[i] = reaper.GetMediaTrackInfo_Value(track, "I_SOLO") state.tracksFX[i] = reaper.TrackFX_GetChainVisible(track) state.tracksDepth[i] = reaper.GetTrackDepth(track) state.isFolder[i] = reaper.GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH") == 1 state.tracksVisible[i] = reaper.GetMediaTrackInfo_Value(track, "B_SHOWINTCP") == 1 state.tracksSel[i] = reaper.IsTrackSelected(track) state.tracksPhase[i] = reaper.GetMediaTrackInfo_Value(track, "B_PHASE") state.tracksArmed[i] = reaper.GetMediaTrackInfo_Value(track, "I_RECARM") == 1 state.tracksHasItems[i] = reaper.CountTrackMediaItems(track) > 0 state.tracksFXCount[i] = reaper.TrackFX_GetCount(track) state.tracksSends[i] = {} state.tracksReceives[i] = {} if state.folderCollapsed[i] == nil then state.folderCollapsed[i] = false end end for i = 1, new_track_count do local src_track = state.tracks[i] local _, src_name = reaper.GetTrackName(src_track) local send_count = reaper.GetTrackNumSends(src_track, 0) for j = 0, send_count - 1 do local dest_track_ptr = reaper.GetTrackSendInfo_Value(src_track, 0, j, "P_DESTTRACK") if dest_track_ptr and reaper.ValidatePtr(dest_track_ptr, "MediaTrack*") then local send_vol = reaper.GetTrackSendInfo_Value(src_track, 0, j, "D_VOL") local send_pan = reaper.GetTrackSendInfo_Value(src_track, 0, j, "D_PAN") local send_mute = reaper.GetTrackSendInfo_Value(src_track, 0, j, "B_MUTE") local _, dest_name = reaper.GetTrackName(dest_track_ptr) table.insert(state.tracksSends[i], { vol = send_vol, pan = send_pan, mute = send_mute, dest_track_name = dest_name }) for k = 1, new_track_count do if state.tracks[k] == dest_track_ptr then table.insert(state.tracksReceives[k], { src_track = src_track, src_track_name = src_name, send_idx = j, vol = send_vol, pan = send_pan, mute = send_mute }) break end end end end end end function save_preset(preset_num) local preset_table = state["preset" .. preset_num] if not preset_table then return end preset_table.track, preset_table.pan, preset_table.vol, preset_table.mute, preset_table.solo = {}, {}, {}, {}, {} for i = 1, #state.tracks do preset_table.track[i] = state.tracks[i] preset_table.pan[i] = state.tracksPan[i] preset_table.vol[i] = state.tracksVol[i] preset_table.mute[i] = state.tracksMut[i] preset_table.solo[i] = state.tracksSol[i] end reaper.ShowMessageBox("Preset " .. preset_num .. " saved.", "Notification", 0) end function load_preset(preset_num) local preset_table = state["preset" .. preset_num] if not preset_table or #preset_table.track == 0 then reaper.ShowMessageBox("Preset " .. preset_num .. " is empty.", "Notification", 0) return end for i = 1, #preset_table.track do local track = state.tracks[i] if track and reaper.ValidatePtr(track, "MediaTrack*") then reaper.SetMediaTrackInfo_Value(track, "D_VOL", preset_table.vol[i]) reaper.SetMediaTrackInfo_Value(track, "D_PAN", preset_table.pan[i]) reaper.SetMediaTrackInfo_Value(track, "B_MUTE", preset_table.mute[i]) reaper.SetMediaTrackInfo_Value(track, "I_SOLO", preset_table.solo[i]) end end reaper.ShowMessageBox("Preset " .. preset_num .. " loaded.", "Notification", 0) end function CycleEditMode() if state.edit_mode == "PAN" then state.edit_mode = "VOL" elseif state.edit_mode == "VOL" then state.edit_mode = "WIDTH" elseif state.edit_mode == "WIDTH" then state.edit_mode = "SENDS" elseif state.edit_mode == "SENDS" then state.edit_mode = "RECEIVES" elseif state.edit_mode == "RECEIVES" then state.edit_mode = "FX PARAMS" else state.edit_mode = "PAN" end if state.sync_view then SyncTrackVisibility() end end function loop() update_and_check_tracks() local visible, is_open_ret = imgui.Begin(ctx, config.win_title, state.is_open) state.is_open = is_open_ret if visible then local content_avail = imgui.GetContentRegionAvail(ctx) local available_w = type(content_avail) == 'table' and content_avail.x or content_avail local preset_btn_w, preset_spacing = 25, 2 local presets_width = (preset_btn_w * 5) + (preset_spacing * 4) local toggle_btn_w, view_combo_w, sync_check_w, group_spacing = 110, 150, 80, 10 local buttons_total_w = presets_width + toggle_btn_w + view_combo_w + sync_check_w + (group_spacing * 4) local search_width = available_w - buttons_total_w - 15 if search_width < 50 then search_width = 50 end imgui.PushItemWidth(ctx, search_width) local filter_changed, new_filter_text = imgui.InputText(ctx, "##Search", state.filter_text, 256) if filter_changed then state.filter_text = new_filter_text end if state.filter_text == "" then local min_x, min_y = imgui.GetItemRectMin(ctx); local max_x, max_y = imgui.GetItemRectMax(ctx) local draw_list = imgui.GetWindowDrawList(ctx) imgui.DrawList_AddText(draw_list, min_x + 5, min_y + ((max_y - min_y) - 16) / 2, PackColor(0.5, 0.5, 0.5, 1.0), "Search...") end imgui.PopItemWidth(ctx) imgui.SameLine(ctx, 0, group_spacing) if imgui.Button(ctx, "EDITING: " .. state.edit_mode, toggle_btn_w, 25) then CycleEditMode() end imgui.SameLine(ctx, 0, group_spacing) imgui.PushItemWidth(ctx, view_combo_w) local combo_changed, new_view_mode = imgui.Combo(ctx, "##ViewMode", state.view_mode - 1, state.view_mode_names_str) if combo_changed then state.view_mode = new_view_mode + 1 if state.sync_view then SyncTrackVisibility() end end imgui.PopItemWidth(ctx) imgui.SameLine(ctx, 0, group_spacing) local sync_changed, new_sync_state = imgui.Checkbox(ctx, "Sync View", state.sync_view) if sync_changed then state.sync_view = new_sync_state if state.sync_view then SyncTrackVisibility() else ResetAllTracksVisibility() end end imgui.SameLine(ctx, 0, group_spacing) for i=1, 5 do if i > 1 then imgui.SameLine(ctx, 0, preset_spacing) end if imgui.Button(ctx, "P"..i, preset_btn_w, 25) then load_preset(i) end if imgui.IsItemClicked(ctx, 1) then save_preset(i) end end imgui.Separator(ctx) if state.edit_mode == "SENDS" then if imgui.BeginTable(ctx, 'SendsLayout', 2, imgui.TableFlags_BordersInnerV + imgui.TableFlags_Resizable) then imgui.TableSetupColumn(ctx, "Tracks", imgui.TableColumnFlags_WidthFixed, 280) imgui.TableSetupColumn(ctx, "Send Controls", imgui.TableColumnFlags_WidthStretch) imgui.TableNextColumn(ctx) if imgui.BeginChild(ctx, "TrackListChildSends", 0, -2) then for i = 1, #state.tracks do if reaper.ValidatePtr(state.tracks[i], "MediaTrack*") and #state.tracksSends[i] > 0 then if ApplyViewFilter(i) then local _, name = reaper.GetTrackName(state.tracks[i]) if state.filter_text == "" or string.find(string.lower(name), string.lower(state.filter_text), 1, true) then local r, g, b = reaper.ColorFromNative(reaper.GetTrackColor(state.tracks[i])) imgui.PushStyleColor(ctx, imgui.Col_Header, PackColor(r/255, g/255, b/255, 0.3)); imgui.PushStyleColor(ctx, imgui.Col_HeaderHovered, PackColor(r/255, g/255, b/255, 0.5)); imgui.PushStyleColor(ctx, imgui.Col_HeaderActive, PackColor(r/255, g/255, b/255, 0.7)) if imgui.Selectable(ctx, string.format("%02d: %s", i, name), state.sends_view_track_idx == i, imgui.SelectableFlags_SpanAllColumns) then state.sends_view_track_idx = i end imgui.PopStyleColor(ctx, 3) end end end end end imgui.EndChild(ctx) imgui.TableNextColumn(ctx) if state.sends_view_track_idx and state.tracks[state.sends_view_track_idx] then local track_idx, track = state.sends_view_track_idx, state.tracks[state.sends_view_track_idx] local _, name = reaper.GetTrackName(track) imgui.Text(ctx, "Editing Sends for: " .. name); imgui.Separator(ctx) if imgui.BeginChild(ctx, "SendControlsChild", 0, -2) then for j, send_info in ipairs(state.tracksSends[track_idx]) do local send_api_idx = j - 1 imgui.Text(ctx, "Send " .. j .. ": -> " .. send_info.dest_track_name) if send_info.mute == 1 then imgui.PushStyleColor(ctx, imgui.Col_Button, PackColor(1,0,0,0.5)) end if imgui.Button(ctx, "Mute##send"..j..track_idx, 50, 0) then reaper.SetTrackSendInfo_Value(track, 0, send_api_idx, "B_MUTE", 1-send_info.mute); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Toggle Send Mute", -1) end if send_info.mute == 1 then imgui.PopStyleColor(ctx) end imgui.SameLine(ctx, 0, 10); imgui.PushItemWidth(ctx, -125) local db, db_int_val = GainToDB(send_info.vol), math.floor(GainToDB(send_info.vol) + 0.5) local vol_changed, new_db_int = imgui.SliderInt(ctx, "##vol_send"..j..track_idx, db_int_val, -100, 12, "") if imgui.IsItemClicked(ctx, 1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx, 0)) then reaper.SetTrackSendInfo_Value(track, 0, send_api_idx, "D_VOL", 1) elseif vol_changed then reaper.SetTrackSendInfo_Value(track, 0, send_api_idx, "D_VOL", DBToGain(new_db_int)); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Send Volume", -1) end imgui.PopItemWidth(ctx); imgui.SameLine(ctx, 0, 5); imgui.Text(ctx, string.format("Vol: %.1f dB", db)) imgui.PushItemWidth(ctx, -80) local pan_val = math.floor(send_info.pan * 100 + 0.5) local pan_changed, new_pan_int = imgui.SliderInt(ctx, "##pan_send"..j..track_idx, pan_val, -100, 100, "Pan: %d") if imgui.IsItemClicked(ctx, 1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx, 0)) then reaper.SetTrackSendInfo_Value(track, 0, send_api_idx, "D_PAN", 0) elseif pan_changed then reaper.SetTrackSendInfo_Value(track, 0, send_api_idx, "D_PAN", new_pan_int / 100); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Send Pan", -1) end imgui.PopItemWidth(ctx); imgui.Separator(ctx) end end imgui.EndChild(ctx) else imgui.Text(ctx, "Select a track from the list on the left to edit its sends.") end imgui.EndTable(ctx) end elseif state.edit_mode == "RECEIVES" then if imgui.BeginTable(ctx, 'ReceivesLayout', 2, imgui.TableFlags_BordersInnerV + imgui.TableFlags_Resizable) then imgui.TableSetupColumn(ctx, "Tracks", imgui.TableColumnFlags_WidthFixed, 280) imgui.TableSetupColumn(ctx, "Receive Controls", imgui.TableColumnFlags_WidthStretch) imgui.TableNextColumn(ctx) if imgui.BeginChild(ctx, "TrackListChildReceives", 0, -2) then for i = 1, #state.tracks do if reaper.ValidatePtr(state.tracks[i], "MediaTrack*") and #state.tracksReceives[i] > 0 then if ApplyViewFilter(i) then local _, name = reaper.GetTrackName(state.tracks[i]) if state.filter_text == "" or string.find(string.lower(name), string.lower(state.filter_text), 1, true) then local r, g, b = reaper.ColorFromNative(reaper.GetTrackColor(state.tracks[i])) imgui.PushStyleColor(ctx, imgui.Col_Header, PackColor(r/255, g/255, b/255, 0.3)); imgui.PushStyleColor(ctx, imgui.Col_HeaderHovered, PackColor(r/255, g/255, b/255, 0.5)); imgui.PushStyleColor(ctx, imgui.Col_HeaderActive, PackColor(r/255, g/255, b/255, 0.7)) if imgui.Selectable(ctx, string.format("%02d: %s", i, name), state.receives_view_track_idx == i, imgui.SelectableFlags_SpanAllColumns) then state.receives_view_track_idx = i end imgui.PopStyleColor(ctx, 3) end end end end end imgui.EndChild(ctx) imgui.TableNextColumn(ctx) if state.receives_view_track_idx and state.tracks[state.receives_view_track_idx] then local track_idx, track = state.receives_view_track_idx, state.tracks[state.receives_view_track_idx] local _, name = reaper.GetTrackName(track) imgui.Text(ctx, "Editing Receives for: " .. name); imgui.Separator(ctx) if imgui.BeginChild(ctx, "ReceiveControlsChild", 0, -2) then for j, receive_info in ipairs(state.tracksReceives[track_idx]) do imgui.Text(ctx, "Receive " .. j .. ": <- From " .. receive_info.src_track_name) if receive_info.mute == 1 then imgui.PushStyleColor(ctx, imgui.Col_Button, PackColor(1,0,0,0.5)) end if imgui.Button(ctx, "Mute##receive"..j..track_idx, 50, 0) then reaper.SetTrackSendInfo_Value(receive_info.src_track, 0, receive_info.send_idx, "B_MUTE", 1-receive_info.mute); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Toggle Receive Mute", -1) end if receive_info.mute == 1 then imgui.PopStyleColor(ctx) end imgui.SameLine(ctx, 0, 10); imgui.PushItemWidth(ctx, -125) local db, db_int_val = GainToDB(receive_info.vol), math.floor(GainToDB(receive_info.vol) + 0.5) local vol_changed, new_db_int = imgui.SliderInt(ctx, "##vol_receive"..j..track_idx, db_int_val, -100, 12, "") if imgui.IsItemClicked(ctx, 1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx, 0)) then reaper.SetTrackSendInfo_Value(receive_info.src_track, 0, receive_info.send_idx, "D_VOL", 1) elseif vol_changed then reaper.SetTrackSendInfo_Value(receive_info.src_track, 0, receive_info.send_idx, "D_VOL", DBToGain(new_db_int)); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Receive Volume", -1) end imgui.PopItemWidth(ctx); imgui.SameLine(ctx, 0, 5); imgui.Text(ctx, string.format("Vol: %.1f dB", db)) imgui.PushItemWidth(ctx, -80) local pan_val = math.floor(receive_info.pan * 100 + 0.5) local pan_changed, new_pan_int = imgui.SliderInt(ctx, "##pan_receive"..j..track_idx, pan_val, -100, 100, "Pan: %d") if imgui.IsItemClicked(ctx, 1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx, 0)) then reaper.SetTrackSendInfo_Value(receive_info.src_track, 0, receive_info.send_idx, "D_PAN", 0) elseif pan_changed then reaper.SetTrackSendInfo_Value(receive_info.src_track, 0, receive_info.send_idx, "D_PAN", new_pan_int / 100); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Receive Pan", -1) end imgui.PopItemWidth(ctx); imgui.Separator(ctx) end end imgui.EndChild(ctx) else imgui.Text(ctx, "Select a track from the list on the left to edit its receives.") end imgui.EndTable(ctx) end else if imgui.BeginTable(ctx, 'MainMixerArea', 2, imgui.TableFlags_BordersInnerV + imgui.TableFlags_Resizable) then imgui.TableSetupColumn(ctx, "Tracks", imgui.TableColumnFlags_WidthFixed, 260) imgui.TableSetupColumn(ctx, "Controls", imgui.TableColumnFlags_WidthStretch) local hide_children_of_collapsed_folder, collapsed_folder_depth = false, -1 for i = 1, #state.tracks do local track = state.tracks[i] if reaper.ValidatePtr(track, "MediaTrack*") then local current_depth = state.tracksDepth[i] if hide_children_of_collapsed_folder and current_depth > collapsed_folder_depth then goto continue_loop elseif hide_children_of_collapsed_folder and current_depth <= collapsed_folder_depth then hide_children_of_collapsed_folder, collapsed_folder_depth = false, -1 end local guid_str = reaper.GetTrackGUID(track) local _, name = reaper.GetTrackName(track) local show_track = true if not (state.filter_text == "" or string.find(string.lower(name), string.lower(state.filter_text), 1, true)) then show_track = false end if show_track and not ApplyViewFilter(i) then show_track = false end if show_track and state.edit_mode == "FX PARAMS" and (not state.pinnedParams[guid_str] or #state.pinnedParams[guid_str] == 0) then show_track = false end if show_track then imgui.TableNextColumn(ctx) if current_depth > 0 then imgui.Indent(ctx, current_depth * config.indent_size) end if imgui.BeginTable(ctx, 'track_line'..i, 3, 0) then imgui.TableSetupColumn(ctx, 'vis'..i, imgui.TableColumnFlags_WidthFixed, 25) imgui.TableSetupColumn(ctx, 'name'..i, imgui.TableColumnFlags_WidthStretch) imgui.TableSetupColumn(ctx, 'buttons'..i, imgui.TableColumnFlags_WidthFixed, 140) imgui.TableNextColumn(ctx) if not state.tracksVisible[i] then imgui.PushStyleColor(ctx, imgui.Col_Text, PackColor(0.6, 0.6, 0.6, 1.0)) end if imgui.Button(ctx, "ðŸ‘##vis"..i, 20, 0) then local new_vis_state = state.tracksVisible[i] and 0 or 1; reaper.SetMediaTrackInfo_Value(track, "B_SHOWINTCP", new_vis_state); reaper.SetMediaTrackInfo_Value(track, "B_SHOWINMIXER", new_vis_state); ForceUIRefresh() end if not state.tracksVisible[i] then imgui.PopStyleColor(ctx) end imgui.TableNextColumn(ctx) local display_name = string.format("%02d: %s", i, name) if state.isFolder[i] then display_name = (state.folderCollapsed[i] and "ðŸ“‚ " or "ðŸ“ ") .. display_name end local r, g, b = reaper.ColorFromNative(reaper.GetTrackColor(track)) imgui.PushStyleColor(ctx, imgui.Col_Header, PackColor(r/255, g/255, b/255, 0.3)); imgui.PushStyleColor(ctx, imgui.Col_HeaderHovered, PackColor(r/255, g/255, b/255, 0.5)); imgui.PushStyleColor(ctx, imgui.Col_HeaderActive, PackColor(r/255, g/255, b/255, 0.7)) if imgui.Selectable(ctx, display_name, state.tracksSel[i]) then reaper.SetTrackSelected(track, not state.tracksSel[i]) end if imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx, 0) and state.isFolder[i] then state.folderCollapsed[i] = not state.folderCollapsed[i] end imgui.PopStyleColor(ctx, 3) if imgui.BeginPopupContextItem(ctx, "TrackContextPopup") then if imgui.MenuItem(ctx, 'Insert New Track') then reaper.defer(function() reaper.Main_OnCommand(40001, 0) end) end; imgui.Separator(ctx) if imgui.MenuItem(ctx, 'Rename Track') then local _, old_name = reaper.GetTrackName(track); local ok, new_name = reaper.GetUserInputs("Rename Track", 1, "New Name:", old_name); if ok and new_name ~= "" then reaper.GetSetMediaTrackInfo_String(track, "P_NAME", new_name, true) end end if imgui.MenuItem(ctx, 'Delete Track') then reaper.defer(function() reaper.DeleteTrack(track) end) end imgui.EndPopup(ctx) end imgui.TableNextColumn(ctx) if state.tracksMut[i]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0,0,0.5)) end; if imgui.Button(ctx,"M##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"B_MUTE",1-state.tracksMut[i]) end; if state.tracksMut[i]==1 then imgui.PopStyleColor(ctx) end; imgui.SameLine(ctx,0,2) if state.tracksSol[i]>0 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,1,0,0.5)) end; if imgui.Button(ctx,"S##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"I_SOLO",state.tracksSol[i]>0 and 0 or 1) end; if state.tracksSol[i]>0 then imgui.PopStyleColor(ctx) end; imgui.SameLine(ctx,0,2) if state.tracksFX[i]~=-1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(0,1,0,0.5)) end; if imgui.Button(ctx,"FX##"..i,20,0) then reaper.TrackFX_Show(track,0,state.tracksFX[i]==-1 and 1 or -1) end; if state.tracksFX[i]~=-1 then imgui.PopStyleColor(ctx) end; imgui.SameLine(ctx,0,2) if state.tracksPhase[i]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0.5,0,0.5)) end; if imgui.Button(ctx,"Ã¸##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"B_PHASE",1-state.tracksPhase[i]) end; if state.tracksPhase[i]==1 then imgui.PopStyleColor(ctx) end; imgui.SameLine(ctx,0,2) local has_pins = state.pinnedParams[guid_str] and #state.pinnedParams[guid_str] > 0 if has_pins then imgui.PushStyleColor(ctx, imgui.Col_Button, PackColor(0.2, 0.6, 1.0, 0.7)) end if imgui.Button(ctx, "Pin##pin"..i, 25, 0) then state.popup_pin_track_idx = i; state.open_pin_popup = true end if has_pins then imgui.PopStyleColor(ctx) end imgui.EndTable(ctx) end if current_depth > 0 then imgui.Unindent(ctx, current_depth * config.indent_size) end imgui.TableNextColumn(ctx) if state.edit_mode == "PAN" then local pan_val = math.floor(state.tracksPan[i]*100+0.5) imgui.PushItemWidth(ctx,-50); local changed,new_pan=imgui.SliderInt(ctx,"##Pan"..i,pan_val,-100,100,""); imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("%d",pan_val)) if changed then reaper.Undo_BeginBlock();local d=new_pan/100-state.tracksPan[i];if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];local p=reaper.GetMediaTrackInfo_Value(t,"D_PAN")+d;reaper.SetMediaTrackInfo_Value(t,"D_PAN",math.max(-1,math.min(1,p))) end end else reaper.SetMediaTrackInfo_Value(track,"D_PAN",new_pan/100) end; reaper.Undo_EndBlock("Adjust Pan",-1) end if imgui.IsItemClicked(ctx,1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_PAN",0) end elseif state.edit_mode == "VOL" then local db=GainToDB(state.tracksVol[i]);local s_val=db>=0 and(db/12)*100 or(db/60)*-100; s_val=math.floor(s_val+0.5) imgui.PushItemWidth(ctx,-60);local ch,new_s=imgui.SliderInt(ctx,"##Vol"..i,s_val,-100,100,"");imgui.PopItemWidth(ctx);imgui.SameLine(ctx,0,5);imgui.Text(ctx,string.format("%.1f dB",db)) if ch then reaper.Undo_BeginBlock();local new_db=new_s>=0 and(new_s/100)*12 or(new_s/100)*-60;local delta=new_db-db;if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];reaper.SetMediaTrackInfo_Value(t,"D_VOL",DBToGain(GainToDB(reaper.GetMediaTrackInfo_Value(t,"D_VOL"))+delta)) end end else reaper.SetMediaTrackInfo_Value(track,"D_VOL",DBToGain(new_db)) end;reaper.Undo_EndBlock("Adjust Vol",-1) end if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_VOL",1) end elseif state.edit_mode == "WIDTH" then local width_val = math.floor(state.tracksWidth[i]*100+0.5) imgui.PushItemWidth(ctx,-50); local changed,new_width_int=imgui.SliderInt(ctx,"##Width"..i,width_val,-100,100,""); imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("%d%%",width_val)) if changed then reaper.Undo_BeginBlock();local new_width = new_width_int/100.0;local d=new_width-state.tracksWidth[i];if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];local w=reaper.GetMediaTrackInfo_Value(t,"D_WIDTH")+d;reaper.SetMediaTrackInfo_Value(t,"D_WIDTH",math.max(-1,math.min(1,w))) end end else reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",new_width) end; reaper.Undo_EndBlock("Adjust Width",-1) end if imgui.IsItemClicked(ctx,1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",1) end elseif state.edit_mode == "FX PARAMS" then if state.pinnedParams[guid_str] then for p_idx, param_info in ipairs(state.pinnedParams[guid_str]) do if imgui.Button(ctx, "X##unpin"..i..p_idx, 20, 0) then table.remove(state.pinnedParams[guid_str], p_idx); save_pinned_params(); goto continue_fx_loop end imgui.SameLine(ctx) local _, param_name = reaper.TrackFX_GetParamName(track, param_info.fx_idx, param_info.param_idx, "") local _, formatted_val = reaper.TrackFX_GetFormattedParamValue(track, param_info.fx_idx, param_info.param_idx, "") imgui.PushItemWidth(ctx, -65) local norm_val = reaper.TrackFX_GetParam(track, param_info.fx_idx, param_info.param_idx) local slider_val = math.floor(norm_val * 1000 + 0.5) local changed, new_slider_val = imgui.SliderInt(ctx, "##fxparam"..i..p_idx, slider_val, 0, 1000, param_name) if changed then reaper.TrackFX_SetParam(track, param_info.fx_idx, param_info.param_idx, new_slider_val / 1000.0); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust FX Parameter", -1) end imgui.PopItemWidth(ctx) imgui.SameLine(ctx, 0, 5) imgui.Text(ctx, formatted_val) ::continue_fx_loop:: end end end if state.isFolder[i] and state.folderCollapsed[i] then hide_children_of_collapsed_folder, collapsed_folder_depth = true, current_depth end end end ::continue_loop:: end imgui.EndTable(ctx) end end if state.open_pin_popup then imgui.OpenPopup(ctx, "PinFXParamPopup") state.open_pin_popup = false end if imgui.BeginPopup(ctx, "PinFXParamPopup") then if state.popup_pin_track_idx then local track = state.tracks[state.popup_pin_track_idx] local _, track_name = reaper.GetTrackName(track) imgui.Text(ctx, "Pin Parameter for: " .. track_name); imgui.Separator(ctx) local fx_count = reaper.TrackFX_GetCount(track) if fx_count > 0 then for fx = 0, fx_count - 1 do local _, fx_name = reaper.TrackFX_GetFXName(track, fx, "") if imgui.TreeNode(ctx, fx_name .. "##fxnode" .. fx) then local param_count = reaper.TrackFX_GetNumParams(track, fx) for p = 0, param_count - 1 do local _, param_name = reaper.TrackFX_GetParamName(track, fx, p, "") if imgui.Selectable(ctx, param_name .. "##param"..p) then local guid_str = reaper.GetTrackGUID(track) local new_pin = {fx_idx = fx, param_idx = p} if not state.pinnedParams[guid_str] then state.pinnedParams[guid_str] = {} end local exists = false for _, pin in ipairs(state.pinnedParams[guid_str]) do if pin.fx_idx == new_pin.fx_idx and pin.param_idx == new_pin.param_idx then exists = true; break end end if not exists then table.insert(state.pinnedParams[guid_str], new_pin) save_pinned_params() end state.popup_pin_track_idx = nil imgui.CloseCurrentPopup(ctx) end end imgui.TreePop(ctx) end end else imgui.Text(ctx, "No FX on this track.") end imgui.Separator(ctx) if imgui.Button(ctx, "Close") then state.popup_pin_track_idx = nil imgui.CloseCurrentPopup(ctx) end end imgui.EndPopup(ctx) end imgui.End(ctx) end if state.is_open then reaper.defer(loop) end end function Main() load_pinned_params() update_and_check_tracks() loop() end reaper.defer(Main)

