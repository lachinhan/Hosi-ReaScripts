--[[
@description    Hosi Mini Track Mixer (ReaImGui Version)
@author         Hosi
@version        1.3
@reaper_version 6.0
@provides
  [main] . > Hosi_Mini Track Mixer (ReaImGui).lua

@about
  # Hosi Mini Track Mixer (ReaImGui Version)

  A small GUI workflow for mixing track volume, pan, width, and FX.

  ## Requirements:
  - REAPER 6.0+
  - js_ReaScriptAPI extension
  - ReaImGui library

@changelog
  v1.3 (2025-10-13)
  - Added: New View Modes: "SELECTED & CHILDREN", "ARMED", "HAS FX", "HAS ITEMS", "MUTED".
  - Added: Stereo Width control. The mode button now cycles through PAN, VOL, and WIDTH.
  - Added: Phase Invert button (Ã¸) for each track.
  - Improved: Replaced "Gang" checkbox with selection-based ganging.
  - Added: Track visibility control and toolbar buttons.
  v1.2 (2025-09-23)
  - Added: Right-click context menu.
  v1.1 (2025-09-23)
  - Added: Double-click to collapse/expand folders.
  v1.0 (2025-09-23)
  - Initial release.
--]]
local config = { win_title = "Hosi Mini Track Mixer v1.3", refresh_interval = 0.05, indent_size = 15.0 } package.path = reaper.ImGui_GetBuiltinPath() .. '/?.lua;' .. package.path local imgui = require('imgui')('0.10') if not imgui or type(imgui) ~= "table" then reaper.ShowMessageBox("Could not initialize ReaImGui library.\n\nPlease install it (v0.10+) via ReaPack.", "ReaImGui Error", 0) return end local ctx = imgui.CreateContext(config.win_title) local new_view_modes = { "ALL", "FOLDERS", "FOLDERS & CHILDREN", "SELECTED", "SELECTED & CHILDREN", "ARMED", "HAS FX", "HAS ITEMS", "MUTED" } local state = { is_open = true, edit_mode = "PAN", view_mode = 1, view_mode_names = new_view_modes, view_mode_names_str = table.concat(new_view_modes, "\0") .. "\0", filter_text = "", tracks = {}, tracksPan = {}, tracksVol = {}, tracksWidth = {}, tracksSel = {}, tracksMut = {}, tracksSol = {}, tracksFX = {}, tracksFXCount = {}, tracksArmed = {}, tracksHasItems = {}, tracksDepth = {}, isFolder = {}, folderCollapsed = {}, tracksVisible = {}, tracksPhase = {}, preset1 = { track = {} }, preset2 = { track = {} }, preset3 = { track = {} }, preset4 = { track = {} }, preset5 = { track = {} } } function PackColor(r, g, b, a) local r_int = math.floor(r * 255 + 0.5) local g_int = math.floor(g * 255 + 0.5) local b_int = math.floor(b * 255 + 0.5) local a_int = math.floor(a * 255 + 0.5) return a_int * 0x1000000 + b_int * 0x10000 + g_int * 0x100 + r_int end function GainToDB(gain) if gain < 0.0000000298 then return -144.0 end return 20 * (math.log(gain) / math.log(10)) end function DBToGain(db) return 10 ^ (db / 20) end function ForceUIRefresh() reaper.TrackList_AdjustWindows(false) reaper.UpdateArrange() end function update_and_check_tracks() local new_track_count = reaper.CountTracks(0) if #state.tracks ~= new_track_count then state.tracks, state.tracksPan, state.tracksVol, state.tracksWidth, state.tracksSel, state.tracksDepth, state.isFolder, state.folderCollapsed, state.tracksVisible, state.tracksPhase, state.tracksArmed, state.tracksHasItems, state.tracksFXCount = {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {} end for i = 1, new_track_count do local track = reaper.GetTrack(0, i - 1) state.tracks[i] = track state.tracksPan[i] = reaper.GetMediaTrackInfo_Value(track, "D_PAN") state.tracksVol[i] = reaper.GetMediaTrackInfo_Value(track, "D_VOL") state.tracksWidth[i] = reaper.GetMediaTrackInfo_Value(track, "D_WIDTH") state.tracksMut[i] = reaper.GetMediaTrackInfo_Value(track, "B_MUTE") state.tracksSol[i] = reaper.GetMediaTrackInfo_Value(track, "I_SOLO") state.tracksFX[i] = reaper.TrackFX_GetChainVisible(track) state.tracksDepth[i] = reaper.GetTrackDepth(track) state.isFolder[i] = reaper.GetMediaTrackInfo_Value(track, "I_FOLDERDEPTH") == 1 state.tracksVisible[i] = reaper.GetMediaTrackInfo_Value(track, "B_SHOWINTCP") == 1 state.tracksSel[i] = reaper.IsTrackSelected(track) state.tracksPhase[i] = reaper.GetMediaTrackInfo_Value(track, "B_PHASE") state.tracksArmed[i] = reaper.GetMediaTrackInfo_Value(track, "I_RECARM") == 1 state.tracksHasItems[i] = reaper.CountTrackMediaItems(track) > 0 state.tracksFXCount[i] = reaper.TrackFX_GetCount(track) if state.folderCollapsed[i] == nil then state.folderCollapsed[i] = false end end end function save_preset(preset_num) local preset_table = state["preset" .. preset_num] if not preset_table then return end preset_table.track, preset_table.pan, preset_table.vol, preset_table.mute, preset_table.solo = {}, {}, {}, {}, {} for i = 1, #state.tracks do preset_table.track[i] = state.tracks[i] preset_table.pan[i] = state.tracksPan[i] preset_table.vol[i] = state.tracksVol[i] preset_table.mute[i] = state.tracksMut[i] preset_table.solo[i] = state.tracksSol[i] end reaper.ShowMessageBox("Preset " .. preset_num .. " saved.", "Notification", 0) end function load_preset(preset_num) local preset_table = state["preset" .. preset_num] if not preset_table or #preset_table.track == 0 then reaper.ShowMessageBox("Preset " .. preset_num .. " is empty.", "Notification", 0) return end for i = 1, #preset_table.track do local track = state.tracks[i] if track and reaper.ValidatePtr(track, "MediaTrack*") then reaper.SetMediaTrackInfo_Value(track, "D_VOL", preset_table.vol[i]) reaper.SetMediaTrackInfo_Value(track, "D_PAN", preset_table.pan[i]) reaper.SetMediaTrackInfo_Value(track, "B_MUTE", preset_table.mute[i]) reaper.SetMediaTrackInfo_Value(track, "I_SOLO", preset_table.solo[i]) end end reaper.ShowMessageBox("Preset " .. preset_num .. " loaded.", "Notification", 0) end function CycleEditMode() if state.edit_mode == "PAN" then state.edit_mode = "VOL" elseif state.edit_mode == "VOL" then state.edit_mode = "WIDTH" else state.edit_mode = "PAN" end end function loop() update_and_check_tracks() local visible, is_open_ret = imgui.Begin(ctx, config.win_title, state.is_open) state.is_open = is_open_ret if visible then local content_avail = imgui.GetContentRegionAvail(ctx) local available_w = type(content_avail) == 'table' and content_avail.x or content_avail local preset_btn_w, preset_spacing = 25, 2 local presets_width = (preset_btn_w * 5) + (preset_spacing * 4) local toggle_btn_w, view_combo_w, group_spacing = 110, 180, 10 local buttons_total_w = presets_width + toggle_btn_w + view_combo_w + (group_spacing * 3) local search_width = available_w - buttons_total_w - 15 if search_width < 50 then search_width = 50 end imgui.PushItemWidth(ctx, search_width) local filter_changed, new_filter_text = imgui.InputText(ctx, "##Search", state.filter_text, 256) if filter_changed then state.filter_text = new_filter_text end if state.filter_text == "" then local min_x, min_y = imgui.GetItemRectMin(ctx); local max_x, max_y = imgui.GetItemRectMax(ctx) local draw_list = imgui.GetWindowDrawList(ctx) imgui.DrawList_AddText(draw_list, min_x + 5, min_y + ((max_y - min_y) - 16) / 2, PackColor(0.5, 0.5, 0.5, 1.0), "Search...") end imgui.PopItemWidth(ctx) imgui.SameLine(ctx, 0, group_spacing) if imgui.Button(ctx, "EDITING: " .. state.edit_mode, toggle_btn_w, 25) then CycleEditMode() end imgui.SameLine(ctx, 0, group_spacing) imgui.PushItemWidth(ctx, view_combo_w) local combo_changed, new_view_mode = imgui.Combo(ctx, "##ViewMode", state.view_mode - 1, state.view_mode_names_str) if combo_changed then state.view_mode = new_view_mode + 1 end imgui.PopItemWidth(ctx) imgui.SameLine(ctx, 0, group_spacing) for i=1, 5 do if i > 1 then imgui.SameLine(ctx, 0, preset_spacing) end if imgui.Button(ctx, "P"..i, preset_btn_w, 25) then load_preset(i) end if imgui.IsItemClicked(ctx, 1) then save_preset(i) end end imgui.Separator(ctx) if imgui.BeginTable(ctx, 'MainMixerArea', 2, imgui.TableFlags_BordersInnerV + imgui.TableFlags_Resizable) then imgui.TableSetupColumn(ctx, "Tracks", imgui.TableColumnFlags_WidthFixed, 260) imgui.TableSetupColumn(ctx, "Controls", imgui.TableColumnFlags_WidthStretch) local hide_children_of_collapsed_folder, collapsed_folder_depth = false, -1 for i = 1, #state.tracks do local track = state.tracks[i] if reaper.ValidatePtr(track, "MediaTrack*") then local current_depth = state.tracksDepth[i] if hide_children_of_collapsed_folder and current_depth > collapsed_folder_depth then goto continue_loop elseif hide_children_of_collapsed_folder and current_depth <= collapsed_folder_depth then hide_children_of_collapsed_folder, collapsed_folder_depth = false, -1 end local _, name = reaper.GetTrackName(track) local show_track = true if not (state.filter_text == "" or string.find(string.lower(name), string.lower(state.filter_text), 1, true)) then show_track = false end if show_track then local current_view_mode = state.view_mode_names[state.view_mode] if current_view_mode == "FOLDERS" then if not state.isFolder[i] then show_track = false end elseif current_view_mode == "FOLDERS & CHILDREN" then if not state.isFolder[i] and state.tracksDepth[i] == 0 then show_track = false end elseif current_view_mode == "SELECTED" then if not state.tracksSel[i] then show_track = false end elseif current_view_mode == "SELECTED & CHILDREN" then local is_visible = state.tracksSel[i] if not is_visible then local parent = reaper.GetParentTrack(track) while parent do if reaper.IsTrackSelected(parent) then is_visible = true break end parent = reaper.GetParentTrack(parent) end end if not is_visible then show_track = false end elseif current_view_mode == "ARMED" then if not state.tracksArmed[i] then show_track = false end elseif current_view_mode == "HAS FX" then if state.tracksFXCount[i] < 1 then show_track = false end elseif current_view_mode == "HAS ITEMS" then if not state.tracksHasItems[i] then show_track = false end elseif current_view_mode == "MUTED" then if state.tracksMut[i] ~= 1 then show_track = false end end end if show_track then imgui.TableNextColumn(ctx) if current_depth > 0 then imgui.Indent(ctx, current_depth * config.indent_size) end if imgui.BeginTable(ctx, 'track_line'..i, 3, 0) then imgui.TableSetupColumn(ctx, 'vis'..i, imgui.TableColumnFlags_WidthFixed, 25) imgui.TableSetupColumn(ctx, 'name'..i, imgui.TableColumnFlags_WidthStretch) imgui.TableSetupColumn(ctx, 'buttons'..i, imgui.TableColumnFlags_WidthFixed, 110) imgui.TableNextColumn(ctx) local is_visible = state.tracksVisible[i] if not is_visible then imgui.PushStyleColor(ctx, imgui.Col_Text, PackColor(0.6, 0.6, 0.6, 1.0)) end if imgui.Button(ctx, "ð##vis"..i, 20, 0) then reaper.SetMediaTrackInfo_Value(track, "B_SHOWINTCP", 1-is_visible); reaper.SetMediaTrackInfo_Value(track, "B_SHOWINMIXER", 1-is_visible); ForceUIRefresh() end if not is_visible then imgui.PopStyleColor(ctx) end imgui.TableNextColumn(ctx) local display_name = string.format("%02d: %s", i, name) if state.isFolder[i] then display_name = (state.folderCollapsed[i] and "ð " or "ð ") .. display_name end local r, g, b = reaper.ColorFromNative(reaper.GetTrackColor(track)) imgui.PushStyleColor(ctx, imgui.Col_Header, PackColor(r/255, g/255, b/255, 0.3)); imgui.PushStyleColor(ctx, imgui.Col_HeaderHovered, PackColor(r/255, g/255, b/255, 0.5)); imgui.PushStyleColor(ctx, imgui.Col_HeaderActive, PackColor(r/255, g/255, b/255, 0.7)) if imgui.Selectable(ctx, display_name, state.tracksSel[i]) then reaper.SetTrackSelected(track, not state.tracksSel[i]) end if imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx, 0) and state.isFolder[i] then state.folderCollapsed[i] = not state.folderCollapsed[i] end imgui.PopStyleColor(ctx, 3) if imgui.BeginPopupContextItem(ctx, "TrackContextPopup") then if imgui.MenuItem(ctx, 'Insert New Track') then reaper.defer(function() reaper.Main_OnCommand(40001, 0) end) end imgui.Separator(ctx) if imgui.MenuItem(ctx, 'Rename Track') then local _, old_name = reaper.GetTrackName(track) local ok, new_name = reaper.GetUserInputs("Rename Track", 1, "New Name:", old_name) if ok and new_name ~= "" then reaper.GetSetMediaTrackInfo_String(track, "P_NAME", new_name, true) end end if imgui.MenuItem(ctx, 'Delete Track') then reaper.defer(function() reaper.DeleteTrack(track) end) end imgui.EndPopup(ctx) end imgui.TableNextColumn(ctx) if state.tracksMut[i]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0,0,0.5)) end; if imgui.Button(ctx,"M##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"B_MUTE",1-state.tracksMut[i]) end; if state.tracksMut[i]==1 then imgui.PopStyleColor(ctx) end imgui.SameLine(ctx,0,2); if state.tracksSol[i]>0 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,1,0,0.5)) end; if imgui.Button(ctx,"S##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"I_SOLO",state.tracksSol[i]>0 and 0 or 1) end; if state.tracksSol[i]>0 then imgui.PopStyleColor(ctx) end imgui.SameLine(ctx,0,2); if state.tracksFX[i]~=-1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(0,1,0,0.5)) end; if imgui.Button(ctx,"FX##"..i,20,0) then reaper.TrackFX_Show(track,0,state.tracksFX[i]==-1 and 1 or -1) end; if state.tracksFX[i]~=-1 then imgui.PopStyleColor(ctx) end imgui.SameLine(ctx,0,2); if state.tracksPhase[i]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0.5,0,0.5)) end; if imgui.Button(ctx,"Ã¸##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"B_PHASE",1-state.tracksPhase[i]) end; if state.tracksPhase[i]==1 then imgui.PopStyleColor(ctx) end imgui.EndTable(ctx) end if current_depth > 0 then imgui.Unindent(ctx, current_depth * config.indent_size) end imgui.TableNextColumn(ctx) if state.edit_mode == "PAN" then local pan_val = math.floor(state.tracksPan[i]*100+0.5) imgui.PushItemWidth(ctx,-50); local changed,new_pan=imgui.SliderInt(ctx,"##Pan"..i,pan_val,-100,100,""); imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("%d",pan_val)) if changed then reaper.Undo_BeginBlock();local d=new_pan/100-state.tracksPan[i];if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];local p=reaper.GetMediaTrackInfo_Value(t,"D_PAN")+d;reaper.SetMediaTrackInfo_Value(t,"D_PAN",math.max(-1,math.min(1,p))) end end else reaper.SetMediaTrackInfo_Value(track,"D_PAN",new_pan/100) end; reaper.Undo_EndBlock("Adjust Pan",-1) end if imgui.IsItemClicked(ctx,1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_PAN",0) end elseif state.edit_mode == "VOL" then local db=GainToDB(state.tracksVol[i]);local s_val=db>=0 and(db/12)*100 or(db/60)*-100; s_val=math.floor(s_val+0.5) imgui.PushItemWidth(ctx,-60);local ch,new_s=imgui.SliderInt(ctx,"##Vol"..i,s_val,-100,100,"");imgui.PopItemWidth(ctx);imgui.SameLine(ctx,0,5);imgui.Text(ctx,string.format("%.1f dB",db)) if ch then reaper.Undo_BeginBlock();local new_db=new_s>=0 and(new_s/100)*12 or(new_s/100)*-60;local delta=new_db-db;if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];reaper.SetMediaTrackInfo_Value(t,"D_VOL",DBToGain(GainToDB(reaper.GetMediaTrackInfo_Value(t,"D_VOL"))+delta)) end end else reaper.SetMediaTrackInfo_Value(track,"D_VOL",DBToGain(new_db)) end;reaper.Undo_EndBlock("Adjust Vol",-1) end if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_VOL",1) end elseif state.edit_mode == "WIDTH" then local width_val = math.floor(state.tracksWidth[i]*100+0.5) imgui.PushItemWidth(ctx,-50); local changed,new_width_int=imgui.SliderInt(ctx,"##Width"..i,width_val,-100,100,""); imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("%d%%",width_val)) if changed then reaper.Undo_BeginBlock();local new_width = new_width_int/100.0;local d=new_width-state.tracksWidth[i];if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];local w=reaper.GetMediaTrackInfo_Value(t,"D_WIDTH")+d;reaper.SetMediaTrackInfo_Value(t,"D_WIDTH",math.max(-1,math.min(1,w))) end end else reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",new_width) end; reaper.Undo_EndBlock("Adjust Width",-1) end if imgui.IsItemClicked(ctx,1) or (imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",1) end end if state.isFolder[i] and state.folderCollapsed[i] then hide_children_of_collapsed_folder, collapsed_folder_depth = true, current_depth end end end ::continue_loop:: end imgui.EndTable(ctx) end imgui.End(ctx) end if state.is_open then reaper.defer(loop) end end function Main() update_and_check_tracks() loop() end reaper.defer(Main)
