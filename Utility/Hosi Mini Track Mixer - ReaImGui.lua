--[[
@description    Hosi Mini Track Mixer (ReaImGui Version)
@author         Hosi
@version        1.7
@reaper_version 6.0
@provides
  [main] . > Hosi_Mini Track Mixer (ReaImGui).lua

@about
  # Hosi Mini Track Mixer (ReaImGui Version)

  A small GUI workflow for mixing track volume, pan, width, sends, receives, and FX.

  ## Requirements:
  - REAPER 6.0+
  - ReaImGui library
  - SWS/S&M Extension (optional, for better track selection focus)

@changelog
  v1.7 (2025-10-17)
  - Added: Drag & Drop functionality to reorder items in the "Configure Menu" window.
  - Improved: Menu configuration window now uses icons for better visual distinction of item types.
  v1.6 (2025-10-16)
  - Added: A customizable user menu (⚙️ icon) to run any REAPER action or script from the toolbar.
  - Added: Configuration window to add/remove custom menu items. Settings are saved globally.
  v1.5 (2025-10-15)
  - Added: A vertical stereo peak meter is now displayed next to the fader in the Channel Strip view for real-time visual feedback.
  - Added: Detailed tooltips for most UI elements to improve user guidance and clarity.
  - Added: Quick Comp controls in the Channel Strip view.
  v1.4 (2025-10-14)
  - Added: Channel Strip View
  - Added: A horizontal stereo VU meter is now displayed for each track, providing real-time visual feedback on audio levels.
  - Added: "Sync View" checkbox to synchronize the script's track filter with REAPER's main track view (TCP/Mixer).
  - Added: When Sync View is active, changing the view mode dropdown will automatically show/hide tracks in the project.
  - Added: Disabling Sync View will reset and show all tracks in the project.
  - Added: Display of the formatted parameter value (e.g., "-12.5 dB") next to each slider in FX PARAMS mode for precise control.
  - Improved: Replaced the static "VIEW" button in SENDS, RECEIVES, and FX PARAMS modes with the persistent View Mode dropdown filter.
  - Improved: The View Mode filter now applies to all editing modes for a more consistent workflow.
  - Added: FX Parameter Control mode. Users can now pin specific plugin parameters to the mixer for direct control.
  - Added: "Pin" button on each track to open a parameter selection window.
  - Added: Track Receives control mode, allowing users to view and manage all incoming signals for a selected track.
  - Added: Track Sends control mode. In this mode, the mixer displays tracks with sends, allowing detailed control over each send's volume, pan, and mute.
  v1.3 (2025-10-13)
  - Added: New View Modes: "SELECTED & CHILDREN", "ARMED", "HAS FX", "HAS ITEMS", "MUTED".
  - Added: Stereo Width control. The mode button now cycles through PAN, VOL, and WIDTH.
  - Added: Phase Invert button (ø) for each track.
  - Improved: Replaced "Gang" checkbox with selection-based ganging.
  - Added: Track visibility control and toolbar buttons.
  v1.2 (2025-09-23)
  - Added: Right-click context menu.
  v1.1 (2025-09-23)
  - Added: Double-click to collapse/expand folders.
  v1.0 (2025-09-23)
  - Initial release.
--]]
local config={win_title="Hosi Mini Track Mixer v1.7",refresh_interval=0.05,indent_size=15.0} package.path=reaper.ImGui_GetBuiltinPath()..'/?.lua;'..package.path local imgui=require('imgui')('0.10') if not imgui or type(imgui)~="table" then reaper.ShowMessageBox("Could not initialize ReaImGui library.\n\nPlease install it (v0.10+) via ReaPack.","ReaImGui Error",0) return end local ctx=imgui.CreateContext(config.win_title) local has_sws_set_last_touched=type(reaper.SetLastTouchedTrack)=='function' local new_view_modes={"ALL","FOLDERS","FOLDERS & CHILDREN","SELECTED","SELECTED & CHILDREN","ARMED","HAS FX","HAS ITEMS","MUTED"} local state={is_open=true,edit_mode="PAN",view_mode=1,view_mode_names=new_view_modes,view_mode_names_str=table.concat(new_view_modes,"\0").."\0",filter_text="",sync_view=false,tracks={},tracksPan={},tracksVol={},tracksWidth={},tracksSel={},tracksMut={},tracksSol={},tracksFX={},tracksFXCount={},tracksArmed={},tracksHasItems={},tracksDepth={},isFolder={},folderCollapsed={},tracksVisible={},tracksPhase={},tracksSends={},tracksReceives={},tracksPeakL={},tracksPeakR={},tracksPeakHoldL={},tracksPeakHoldR={},last_selected_track_idx=nil,sends_view_track_idx=nil,receives_view_track_idx=nil,pinnedParams={},popup_pin_track_idx=nil,open_pin_popup=false,last_update_time=0,quickControls={reaComp_idx=nil,reaComp_params={}},preset1={track={}},preset2={track={}},preset3={track={}},preset4={track={}},preset5={track={}},customMenu={},open_custom_menu_config=false,new_menu_item_name="",new_menu_item_id="",new_menu_item_type_idx=0,menu_config_target_table=nil,dnd_source_path=nil,dnd_target_path=nil,dnd_drop_type=nil,item_to_delete_path=nil} function PackColor(r,g,b,a) local r_int=math.floor(r*255+0.5) local g_int=math.floor(g*255+0.5) local b_int=math.floor(b*255+0.5) local a_int=math.floor(a*255+0.5) return a_int*0x1000000+b_int*0x10000+g_int*0x100+r_int end function GainToDB(gain) if gain<0.0000000298 then return -144.0 end return 20*(math.log(gain)/math.log(10)) end function DBToGain(db) return 10^(db/20) end function ShowTooltip(text) if imgui.IsItemHovered(ctx) then imgui.BeginTooltip(ctx) imgui.Text(ctx,text) imgui.EndTooltip(ctx) end end function ForceUIRefresh() reaper.TrackList_AdjustWindows(false) reaper.UpdateArrange() end function DrawVUMeter(ctx,height,peakL_gain,peakR_gain,peakHoldL_gain,peakHoldR_gain,track_idx) local draw_list=imgui.GetWindowDrawList(ctx) local screen_px,screen_py=imgui.GetCursorScreenPos(ctx) local meter_w,meter_spacing=25,4 local total_w=meter_w*2+meter_spacing local text_height=20 imgui.InvisibleButton(ctx,"##vu_placeholder_area",total_w,height+text_height) if imgui.IsItemClicked(ctx,0) then state.tracksPeakHoldL[track_idx]=0 state.tracksPeakHoldR[track_idx]=0 ShowTooltip("Peak Reset") else ShowTooltip("Click meter to reset peak hold") end local col_bg=PackColor(0.2,0.2,0.2,1) local col_green=PackColor(0.1,1.0,0.1,1) local col_yellow=PackColor(1.0,1.0,0.1,1) local col_red=PackColor(1.0,0.2,0.2,1) local col_peak_hold=PackColor(1.0,1.0,1.0,1) local function DrawBar(x_offset,peak_gain,peak_hold_gain) local db=GainToDB(peak_gain) local meter_range_db=60 local meter_headroom_db=6 local bar_h=0 if db>=-meter_range_db then bar_h=(db+meter_range_db)/(meter_range_db+meter_headroom_db)*height bar_h=math.min(bar_h,height) end imgui.DrawList_AddRectFilled(draw_list,screen_px+x_offset,screen_py,screen_px+x_offset+meter_w,screen_py+height,col_bg) if bar_h>0 then local yellow_thresh=height*(meter_range_db-9)/(meter_range_db+meter_headroom_db) local red_thresh=height*meter_range_db/(meter_range_db+meter_headroom_db) local green_h=math.min(bar_h,yellow_thresh) imgui.DrawList_AddRectFilled(draw_list,screen_px+x_offset,screen_py+height-green_h,screen_px+x_offset+meter_w,screen_py+height,col_green) if bar_h>yellow_thresh then local yellow_h=math.min(bar_h,red_thresh)-yellow_thresh imgui.DrawList_AddRectFilled(draw_list,screen_px+x_offset,screen_py+height-yellow_thresh-yellow_h,screen_px+x_offset+meter_w,screen_py+height-yellow_thresh,col_yellow) end if bar_h>red_thresh then local red_h=bar_h-red_thresh imgui.DrawList_AddRectFilled(draw_list,screen_px+x_offset,screen_py+height-red_thresh-red_h,screen_px+x_offset+meter_w,screen_py+height-red_thresh,col_red) end end local peak_hold_db=GainToDB(peak_hold_gain) if peak_hold_db>-meter_range_db then local peak_y_pos_h=(peak_hold_db+meter_range_db)/(meter_range_db+meter_headroom_db)*height local peak_y_pos=screen_py+height-math.min(peak_y_pos_h,height) imgui.DrawList_AddLine(draw_list,screen_px+x_offset,peak_y_pos,screen_px+x_offset+meter_w,peak_y_pos,col_peak_hold,1.5) end end DrawBar(0,peakL_gain,peakHoldL_gain) DrawBar(meter_w+meter_spacing,peakR_gain,peakHoldR_gain) local peak_hold_db_l=GainToDB(peakHoldL_gain) local peak_hold_db_r=GainToDB(peakHoldR_gain) local text_l=(peak_hold_db_l<-99) and "-inf" or string.format("%.1f",peak_hold_db_l) local text_r=(peak_hold_db_r<-99) and "-inf" or string.format("%.1f",peak_hold_db_r) local text_w_l=imgui.CalcTextSize(ctx,text_l) local text_w_r=imgui.CalcTextSize(ctx,text_r) local text_y_pos=screen_py+height+3 imgui.DrawList_AddText(draw_list,screen_px+(meter_w-text_w_l)/2,text_y_pos,PackColor(0.8,0.8,0.8,1),text_l) imgui.DrawList_AddText(draw_list,screen_px+meter_w+meter_spacing+(meter_w-text_w_r)/2,text_y_pos,PackColor(0.8,0.8,0.8,1),text_r) end function save_pinned_params() local data_parts={} for guid,pins in pairs(state.pinnedParams) do if pins and #pins>0 then local pin_parts={} for _,pin in ipairs(pins) do table.insert(pin_parts,pin.fx_idx..","..pin.param_idx) end table.insert(data_parts,guid..":"..table.concat(pin_parts,";")) end end local data_string=table.concat(data_parts,"|") reaper.SetProjExtState(0,"Hosi.MiniTrackMixer","Pins",data_string) end function load_pinned_params() local _,data_string=reaper.GetProjExtState(0,"Hosi.MiniTrackMixer","Pins") state.pinnedParams={} if data_string and data_string~="" then for track_data in string.gmatch(data_string,"([^|]+)") do local guid,pins_str=string.match(track_data,"([^:]+):([^:]+)") if guid and pins_str then state.pinnedParams[guid]={} for pin_data in string.gmatch(pins_str,"([^;]+)") do local fx_idx,param_idx=string.match(pin_data,"([^,]+),([^,]+)") if fx_idx and param_idx then table.insert(state.pinnedParams[guid],{fx_idx=tonumber(fx_idx),param_idx=tonumber(param_idx)}) end end end end end end function serialize_table(val) if type(val)=="string" then return string.format("%q",val) elseif type(val)=="number" or type(val)=="boolean" then return tostring(val) elseif type(val)=="table" then local parts={} local is_array=true local n=0 for k,_ in pairs(val) do n=n+1 if type(k)~="number" or k~=n then is_array=false end end if n~=#val then is_array=false end for k,v in ipairs(val) do table.insert(parts,serialize_table(v)) end if not is_array then for k,v in pairs(val) do if type(k)=="number" and k>0 and k<=#val and val[k]==v then else table.insert(parts,string.format("[%s]=%s",serialize_table(k),serialize_table(v))) end end end return"{"..table.concat(parts,",").."}" else return"nil" end end function save_custom_menu() local data_string=serialize_table(state.customMenu) reaper.SetExtState("Hosi.MiniTrackMixer","CustomMenu",data_string,true) end function load_custom_menu() local data_string=reaper.GetExtState("Hosi.MiniTrackMixer","CustomMenu") if data_string and data_string~="" then local success,result=pcall(load("return "..data_string)) if success and type(result)=="table" then state.customMenu=result else state.customMenu={} end else state.customMenu={} end end function ApplyViewFilter(i) local track=state.tracks[i] local show_track=true local current_view_mode=state.view_mode_names[state.view_mode] if current_view_mode=="FOLDERS" then if not state.isFolder[i] then show_track=false end elseif current_view_mode=="FOLDERS & CHILDREN" then if not state.isFolder[i] and state.tracksDepth[i]==0 then show_track=false end elseif current_view_mode=="SELECTED" then if not state.tracksSel[i] then show_track=false end elseif current_view_mode=="SELECTED & CHILDREN" then local is_visible=state.tracksSel[i] if not is_visible then local parent=reaper.GetParentTrack(track) while parent do if reaper.IsTrackSelected(parent) then is_visible=true break end parent=reaper.GetParentTrack(parent) end end if not is_visible then show_track=false end elseif current_view_mode=="ARMED" then if not state.tracksArmed[i] then show_track=false end elseif current_view_mode=="HAS FX" then if state.tracksFXCount[i]<1 then show_track=false end elseif current_view_mode=="HAS ITEMS" then if not state.tracksHasItems[i] then show_track=false end elseif current_view_mode=="MUTED" then if state.tracksMut[i]~=1 then show_track=false end end return show_track end function SyncTrackVisibility() reaper.Undo_BeginBlock() reaper.PreventUIRefresh(1) for i=1,#state.tracks do local guid_str=reaper.GetTrackGUID(state.tracks[i]) local should_show=ApplyViewFilter(i) if state.edit_mode=="SENDS" and #state.tracksSends[i]==0 then should_show=false elseif state.edit_mode=="RECEIVES" and #state.tracksReceives[i]==0 then should_show=false elseif state.edit_mode=="FX PARAMS" and(not state.pinnedParams[guid_str] or #state.pinnedParams[guid_str]==0) then should_show=false end local new_vis_state=should_show and 1 or 0 reaper.SetMediaTrackInfo_Value(state.tracks[i],"B_SHOWINTCP",new_vis_state) reaper.SetMediaTrackInfo_Value(state.tracks[i],"B_SHOWINMIXER",new_vis_state) end reaper.PreventUIRefresh(-1) reaper.Undo_EndBlock("Sync Track Visibility",-1) ForceUIRefresh() end function ResetAllTracksVisibility() reaper.Undo_BeginBlock() reaper.PreventUIRefresh(1) for i=1,#state.tracks do reaper.SetMediaTrackInfo_Value(state.tracks[i],"B_SHOWINTCP",1) reaper.SetMediaTrackInfo_Value(state.tracks[i],"B_SHOWINMIXER",1) end reaper.PreventUIRefresh(-1) reaper.Undo_EndBlock("Show All Tracks",-1) ForceUIRefresh() end function update_quick_controls(track) state.quickControls={reaComp_idx=nil,reaComp_params={}} if not track then return end local fx_count=reaper.TrackFX_GetCount(track) for i=0,fx_count-1 do local _,fx_name=reaper.TrackFX_GetFXName(track,i,"") if fx_name then if not state.quickControls.reaComp_idx and fx_name:find("ReaComp",1,true) then state.quickControls.reaComp_idx=i state.quickControls.reaComp_params.bypass=reaper.TrackFX_GetEnabled(track,i) break end end end end function update_and_check_tracks() local new_track_count=reaper.CountTracks(0) local last_track_count=#state.tracks if last_track_count~=new_track_count then state.tracks,state.tracksPan,state.tracksVol,state.tracksWidth,state.tracksSel,state.tracksDepth,state.isFolder,state.folderCollapsed,state.tracksVisible,state.tracksPhase,state.tracksArmed,state.tracksHasItems,state.tracksFXCount,state.tracksSends,state.tracksReceives,state.tracksPeakL,state.tracksPeakR,state.tracksPeakHoldL,state.tracksPeakHoldR={},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{} end state.last_selected_track_idx=nil local last_sel_track=reaper.GetLastTouchedTrack() for i=1,new_track_count do local track=reaper.GetTrack(0,i-1) state.tracks[i]=track state.tracksPan[i]=reaper.GetMediaTrackInfo_Value(track,"D_PAN") state.tracksVol[i]=reaper.GetMediaTrackInfo_Value(track,"D_VOL") state.tracksWidth[i]=reaper.GetMediaTrackInfo_Value(track,"D_WIDTH") state.tracksMut[i]=reaper.GetMediaTrackInfo_Value(track,"B_MUTE") state.tracksSol[i]=reaper.GetMediaTrackInfo_Value(track,"I_SOLO") state.tracksFX[i]=reaper.TrackFX_GetChainVisible(track) state.tracksDepth[i]=reaper.GetTrackDepth(track) state.isFolder[i]=reaper.GetMediaTrackInfo_Value(track,"I_FOLDERDEPTH")==1 state.tracksVisible[i]=reaper.GetMediaTrackInfo_Value(track,"B_SHOWINTCP")==1 state.tracksSel[i]=reaper.IsTrackSelected(track) state.tracksPhase[i]=reaper.GetMediaTrackInfo_Value(track,"B_PHASE") state.tracksArmed[i]=reaper.GetMediaTrackInfo_Value(track,"I_RECARM")==1 state.tracksHasItems[i]=reaper.CountTrackMediaItems(track)>0 state.tracksFXCount[i]=reaper.TrackFX_GetCount(track) local currentPeakL_gain=reaper.Track_GetPeakInfo(track,0) local currentPeakR_gain=reaper.Track_GetPeakInfo(track,1) state.tracksPeakL[i]=currentPeakL_gain state.tracksPeakR[i]=currentPeakR_gain state.tracksPeakHoldL[i]=state.tracksPeakHoldL[i] or 0 state.tracksPeakHoldR[i]=state.tracksPeakHoldR[i] or 0 if currentPeakL_gain>state.tracksPeakHoldL[i] then state.tracksPeakHoldL[i]=currentPeakL_gain end if currentPeakR_gain>state.tracksPeakHoldR[i] then state.tracksPeakHoldR[i]=currentPeakR_gain end state.tracksSends[i]={} state.tracksReceives[i]={} if state.folderCollapsed[i]==nil then state.folderCollapsed[i]=false end if last_sel_track and track==last_sel_track then state.last_selected_track_idx=i end end if state.last_selected_track_idx then update_quick_controls(state.tracks[state.last_selected_track_idx]) else update_quick_controls(nil) end for i=1,new_track_count do local src_track=state.tracks[i] local _,src_name=reaper.GetTrackName(src_track) local send_count=reaper.GetTrackNumSends(src_track,0) for j=0,send_count-1 do local dest_track_ptr=reaper.GetTrackSendInfo_Value(src_track,0,j,"P_DESTTRACK") if dest_track_ptr and reaper.ValidatePtr(dest_track_ptr,"MediaTrack*") then local send_vol=reaper.GetTrackSendInfo_Value(src_track,0,j,"D_VOL") local send_pan=reaper.GetTrackSendInfo_Value(src_track,0,j,"D_PAN") local send_mute=reaper.GetTrackSendInfo_Value(src_track,0,j,"B_MUTE") local _,dest_name=reaper.GetTrackName(dest_track_ptr) table.insert(state.tracksSends[i],{vol=send_vol,pan=send_pan,mute=send_mute,dest_track_name=dest_name}) for k=1,new_track_count do if state.tracks[k]==dest_track_ptr then table.insert(state.tracksReceives[k],{src_track=src_track,src_track_name=src_name,send_idx=j,vol=send_vol,pan=send_pan,mute=send_mute}) break end end end end end end function save_preset(preset_num) local preset_table=state["preset"..preset_num] if not preset_table then return end preset_table.track,preset_table.pan,preset_table.vol,preset_table.mute,preset_table.solo={},{},{},{},{} for i=1,#state.tracks do preset_table.track[i]=state.tracks[i] preset_table.pan[i]=state.tracksPan[i] preset_table.vol[i]=state.tracksVol[i] preset_table.mute[i]=state.tracksMut[i] preset_table.solo[i]=state.tracksSol[i] end reaper.ShowMessageBox("Preset "..preset_num.." saved.","Notification",0) end function load_preset(preset_num) local preset_table=state["preset"..preset_num] if not preset_table or #preset_table.track==0 then reaper.ShowMessageBox("Preset "..preset_num.." is empty.","Notification",0) return end for i=1,#preset_table.track do local track=state.tracks[i] if track and reaper.ValidatePtr(track,"MediaTrack*") then reaper.SetMediaTrackInfo_Value(track,"D_VOL",preset_table.vol[i]) reaper.SetMediaTrackInfo_Value(track,"D_PAN",preset_table.pan[i]) reaper.SetMediaTrackInfo_Value(track,"B_MUTE",preset_table.mute[i]) reaper.SetMediaTrackInfo_Value(track,"I_SOLO",preset_table.solo[i]) end end reaper.ShowMessageBox("Preset "..preset_num.." loaded.","Notification",0) end function CycleEditMode() if state.edit_mode=="PAN" then state.edit_mode="VOL" elseif state.edit_mode=="VOL" then state.edit_mode="WIDTH" elseif state.edit_mode=="WIDTH" then state.edit_mode="SENDS" elseif state.edit_mode=="SENDS" then state.edit_mode="RECEIVES" elseif state.edit_mode=="RECEIVES" then state.edit_mode="FX PARAMS" elseif state.edit_mode=="FX PARAMS" then state.edit_mode="CHAN STRIP" else state.edit_mode="PAN" end if state.sync_view then SyncTrackVisibility() end end function DrawRecursiveMenu(menu_table) for _,item in ipairs(menu_table) do if item.type=="item" then if imgui.MenuItem(ctx,item.name) then local num_cmd=tonumber(item.commandId) if num_cmd then reaper.Main_OnCommand(num_cmd,0) else reaper.Main_OnCommand(reaper.NamedCommandLookup(item.commandId),0) end end elseif item.type=="menu" then if imgui.BeginMenu(ctx,item.name) then DrawRecursiveMenu(item.items) imgui.EndMenu(ctx) end elseif item.type=="separator" then imgui.Separator(ctx) end end end function get_parent_table_and_index(path_str) local path={} for part in string.gmatch(path_str,"[^%.]+") do table.insert(path,tonumber(part)) end if #path==0 then return nil,nil end local parent={items=state.customMenu} local current_table=state.customMenu for i=1,#path-1 do local idx=path[i] local item=current_table[idx] if item and item.type=='menu' and item.items then parent=item current_table=item.items else return nil,nil end end return parent.items,path[#path] end function execute_menu_move(source_path,target_path,drop_type) local source_parent,source_idx=get_parent_table_and_index(source_path) if not source_parent then return end local item_to_move=table.remove(source_parent,source_idx) if not item_to_move then return end if drop_type=='into' then local target_parent_table,target_idx=get_parent_table_and_index(target_path) if string.find(target_path,source_path..".",1,true) then table.insert(source_parent,source_idx,item_to_move) return end if target_parent_table and target_parent_table[target_idx] and target_parent_table[target_idx].type=='menu' then local target_item=target_parent_table[target_idx] table.insert(target_item.items,item_to_move) else table.insert(source_parent,source_idx,item_to_move) end else local target_parent,target_idx=get_parent_table_and_index(target_path) if not target_parent then table.insert(source_parent,source_idx,item_to_move) return end if source_parent==target_parent and source_idx<target_idx then target_idx=target_idx-1 end table.insert(target_parent,target_idx,item_to_move) end save_custom_menu() end function execute_menu_delete(path_to_delete) local parent_table,idx=get_parent_table_and_index(path_to_delete) if parent_table and idx then table.remove(parent_table,idx) save_custom_menu() end end function DrawMenuConfiguration(menu_table,path_prefix) for i,item in ipairs(menu_table) do local current_path=path_prefix..i local id_str=tostring(item) imgui.InvisibleButton(ctx,"drop_target_before##"..current_path,-1,4) if imgui.BeginDragDropTarget(ctx) then local success,payload_str=imgui.AcceptDragDropPayload(ctx,"CUSTOM_MENU_ITEM") if success and payload_str~=current_path then state.dnd_source_path=payload_str state.dnd_target_path=current_path state.dnd_drop_type='before' end imgui.EndDragDropTarget(ctx) end local node_open=false local item_label if item.type=="menu" then item_label="📁 "..item.name.." (Sub-menu)" elseif item.type=="item" then item_label="📄 "..item.name.." (Action)" elseif item.type=="separator" then item_label="--- Separator ---" end if item.type=="menu" then node_open=imgui.TreeNode(ctx,item_label.."##"..id_str) else imgui.Selectable(ctx,item_label.."##"..id_str,false) end if imgui.BeginDragDropSource(ctx) then imgui.SetDragDropPayload(ctx,"CUSTOM_MENU_ITEM",current_path) imgui.Text(ctx,"Moving: "..item.name) imgui.EndDragDropSource(ctx) end if item.type=='menu' then if imgui.BeginDragDropTarget(ctx) then local success,payload_str=imgui.AcceptDragDropPayload(ctx,"CUSTOM_MENU_ITEM") if success and payload_str~=current_path then state.dnd_source_path=payload_str state.dnd_target_path=current_path state.dnd_drop_type='into' end imgui.EndDragDropTarget(ctx) end end if imgui.IsItemClicked(ctx,0) and item.type=="menu" then state.menu_config_target_table=item.items end imgui.SameLine(ctx) if imgui.SmallButton(ctx,"Delete##"..id_str) then state.item_to_delete_path=current_path end if node_open then DrawMenuConfiguration(item.items,current_path..".") imgui.TreePop(ctx) end end imgui.InvisibleButton(ctx,"drop_target_end##"..path_prefix,-1,4) if imgui.BeginDragDropTarget(ctx) then local success,payload_str=imgui.AcceptDragDropPayload(ctx,"CUSTOM_MENU_ITEM") if success then local target_path=path_prefix..(#menu_table+1) state.dnd_source_path=payload_str state.dnd_target_path=target_path state.dnd_drop_type='before' end imgui.EndDragDropTarget(ctx) end end function loop() local current_time=reaper.time_precise() if current_time-state.last_update_time>config.refresh_interval then update_and_check_tracks() state.last_update_time=current_time end local visible,is_open_ret=imgui.Begin(ctx,config.win_title,state.is_open) state.is_open=is_open_ret if visible then local content_avail=imgui.GetContentRegionAvail(ctx) local available_w=type(content_avail)=='table' and content_avail.x or content_avail local preset_btn_w,preset_spacing=25,2 local custom_menu_w=24 local presets_width=(preset_btn_w*5)+(preset_spacing*4) local toggle_btn_w,view_combo_w,sync_check_w,group_spacing=130,150,80,10 local buttons_total_w=presets_width+toggle_btn_w+view_combo_w+sync_check_w+custom_menu_w+(group_spacing*5) local search_width=available_w-buttons_total_w-15 if search_width<50 then search_width=50 end imgui.PushItemWidth(ctx,search_width) local filter_changed,new_filter_text=imgui.InputText(ctx,"##Search",state.filter_text,256) if filter_changed then state.filter_text=new_filter_text end ShowTooltip("Search for tracks by name.") if state.filter_text=="" then local min_x,min_y=imgui.GetItemRectMin(ctx); local max_x,max_y=imgui.GetItemRectMax(ctx) local draw_list=imgui.GetWindowDrawList(ctx) imgui.DrawList_AddText(draw_list,min_x+5,min_y+((max_y-min_y)-16)/2,PackColor(0.5,0.5,0.5,1.0),"Search...") end imgui.PopItemWidth(ctx) imgui.SameLine(ctx,0,group_spacing) if imgui.Button(ctx,"EDITING: "..state.edit_mode,toggle_btn_w,25) then CycleEditMode() end ShowTooltip("Click to cycle through editing modes:\nPAN -> VOL -> WIDTH -> SENDS -> RECEIVES -> FX PARAMS -> CHANNEL STRIP") imgui.SameLine(ctx,0,group_spacing) imgui.PushItemWidth(ctx,view_combo_w) local combo_changed,new_view_mode=imgui.Combo(ctx,"##ViewMode",state.view_mode-1,state.view_mode_names_str) if combo_changed then state.view_mode=new_view_mode+1 if state.sync_view then SyncTrackVisibility() end end ShowTooltip("Filter the track list by criteria.") imgui.PopItemWidth(ctx) imgui.SameLine(ctx,0,group_spacing) local sync_changed,new_sync_state=imgui.Checkbox(ctx,"Sync View",state.sync_view) if sync_changed then state.sync_view=new_sync_state if state.sync_view then SyncTrackVisibility() else ResetAllTracksVisibility() end end ShowTooltip("When checked, hides/shows tracks in REAPER\nto match the current filter applied in the script.") imgui.SameLine(ctx,0,group_spacing) for i=1,5 do if i>1 then imgui.SameLine(ctx,0,preset_spacing) end if imgui.Button(ctx,"P"..i,preset_btn_w,25) then load_preset(i) end if imgui.IsItemClicked(ctx,1) then save_preset(i) end ShowTooltip("Left-click to Load Preset.\nRight-click to Save Preset.") end imgui.SameLine(ctx,0,group_spacing) if imgui.Button(ctx,"⚙️##customMenu",custom_menu_w,25) then imgui.OpenPopup(ctx,"CustomMenuPopup") end ShowTooltip("Open the custom menu.") if imgui.BeginPopup(ctx,"CustomMenuPopup") then if #state.customMenu>0 then DrawRecursiveMenu(state.customMenu) imgui.Separator(ctx) else imgui.TextDisabled(ctx,"(Menu is empty)") end if imgui.MenuItem(ctx,"Configure Menu...") then state.open_custom_menu_config=true state.menu_config_target_table=state.customMenu end imgui.EndPopup(ctx) end imgui.Separator(ctx) if state.edit_mode=="SENDS" then if imgui.BeginTable(ctx,'SendsLayout',2,imgui.TableFlags_BordersInnerV+imgui.TableFlags_Resizable) then imgui.TableSetupColumn(ctx,"Tracks",imgui.TableColumnFlags_WidthFixed,280) imgui.TableSetupColumn(ctx,"Send Controls",imgui.TableColumnFlags_WidthStretch) imgui.TableNextColumn(ctx) if imgui.BeginChild(ctx,"TrackListChildSends",0,-2) then for i=1,#state.tracks do if reaper.ValidatePtr(state.tracks[i],"MediaTrack*") and #state.tracksSends[i]>0 then if ApplyViewFilter(i) then local _,name=reaper.GetTrackName(state.tracks[i]) if state.filter_text=="" or string.find(string.lower(name),string.lower(state.filter_text),1,true) then local r,g,b=reaper.ColorFromNative(reaper.GetTrackColor(state.tracks[i])) imgui.PushStyleColor(ctx,imgui.Col_Header,PackColor(r/255,g/255,b/255,0.3)); imgui.PushStyleColor(ctx,imgui.Col_HeaderHovered,PackColor(r/255,g/255,b/255,0.5)); imgui.PushStyleColor(ctx,imgui.Col_HeaderActive,PackColor(r/255,g/255,b/255,0.7)) if imgui.Selectable(ctx,string.format("%02d: %s",i,name),state.sends_view_track_idx==i,imgui.SelectableFlags_SpanAllColumns) then state.sends_view_track_idx=i end ShowTooltip("Select to view this track's sends.") imgui.PopStyleColor(ctx,3) end end end end end imgui.EndChild(ctx) imgui.TableNextColumn(ctx) if state.sends_view_track_idx and state.tracks[state.sends_view_track_idx] then local track_idx,track=state.sends_view_track_idx,state.tracks[state.sends_view_track_idx] local _,name=reaper.GetTrackName(track) imgui.Text(ctx,"Editing Sends for: "..name); imgui.Separator(ctx) if imgui.BeginChild(ctx,"SendControlsChild",0,-2) then for j,send_info in ipairs(state.tracksSends[track_idx]) do local send_api_idx=j-1 imgui.Text(ctx,"Send "..j..": -> "..send_info.dest_track_name) if send_info.mute==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0,0,0.5)) end if imgui.Button(ctx,"Mute##send"..j..track_idx,50,0) then reaper.SetTrackSendInfo_Value(track,0,send_api_idx,"B_MUTE",1-send_info.mute); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Toggle Send Mute",-1) end if send_info.mute==1 then imgui.PopStyleColor(ctx) end ShowTooltip("Mute/Unmute this send.") imgui.SameLine(ctx,0,10); imgui.PushItemWidth(ctx,-125) local db,db_int_val=GainToDB(send_info.vol),math.floor(GainToDB(send_info.vol)+0.5) local vol_changed,new_db_int=imgui.SliderInt(ctx,"##vol_send"..j..track_idx,db_int_val,-100,12,"") ShowTooltip(string.format("Volume: %.2f dB\nDouble-click or right-click to reset to 0dB.",db)) if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetTrackSendInfo_Value(track,0,send_api_idx,"D_VOL",1) elseif vol_changed then reaper.SetTrackSendInfo_Value(track,0,send_api_idx,"D_VOL",DBToGain(new_db_int)); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Send Volume",-1) end imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("Vol: %.1f dB",db)) imgui.PushItemWidth(ctx,-80) local pan_val=math.floor(send_info.pan*100+0.5) local pan_changed,new_pan_int=imgui.SliderInt(ctx,"##pan_send"..j..track_idx,pan_val,-100,100,"Pan: %d") ShowTooltip("Double-click or right-click to reset to center.") if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetTrackSendInfo_Value(track,0,send_api_idx,"D_PAN",0) elseif pan_changed then reaper.SetTrackSendInfo_Value(track,0,send_api_idx,"D_PAN",new_pan_int/100); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Send Pan",-1) end imgui.PopItemWidth(ctx); imgui.Separator(ctx) end end imgui.EndChild(ctx) else imgui.Text(ctx,"Select a track from the list on the left to edit its sends.") end imgui.EndTable(ctx) end elseif state.edit_mode=="RECEIVES" then if imgui.BeginTable(ctx,'ReceivesLayout',2,imgui.TableFlags_BordersInnerV+imgui.TableFlags_Resizable) then imgui.TableSetupColumn(ctx,"Tracks",imgui.TableColumnFlags_WidthFixed,280) imgui.TableSetupColumn(ctx,"Receive Controls",imgui.TableColumnFlags_WidthStretch) imgui.TableNextColumn(ctx) if imgui.BeginChild(ctx,"TrackListChildReceives",0,-2) then for i=1,#state.tracks do if reaper.ValidatePtr(state.tracks[i],"MediaTrack*") and #state.tracksReceives[i]>0 then if ApplyViewFilter(i) then local _,name=reaper.GetTrackName(state.tracks[i]) if state.filter_text=="" or string.find(string.lower(name),string.lower(state.filter_text),1,true) then local r,g,b=reaper.ColorFromNative(reaper.GetTrackColor(state.tracks[i])) imgui.PushStyleColor(ctx,imgui.Col_Header,PackColor(r/255,g/255,b/255,0.3)); imgui.PushStyleColor(ctx,imgui.Col_HeaderHovered,PackColor(r/255,g/255,b/255,0.5)); imgui.PushStyleColor(ctx,imgui.Col_HeaderActive,PackColor(r/255,g/255,b/255,0.7)) if imgui.Selectable(ctx,string.format("%02d: %s",i,name),state.receives_view_track_idx==i,imgui.SelectableFlags_SpanAllColumns) then state.receives_view_track_idx=i end ShowTooltip("Select to view this track's receives.") imgui.PopStyleColor(ctx,3) end end end end end imgui.EndChild(ctx) imgui.TableNextColumn(ctx) if state.receives_view_track_idx and state.tracks[state.receives_view_track_idx] then local track_idx,track=state.receives_view_track_idx,state.tracks[state.receives_view_track_idx] local _,name=reaper.GetTrackName(track) imgui.Text(ctx,"Editing Receives for: "..name); imgui.Separator(ctx) if imgui.BeginChild(ctx,"ReceiveControlsChild",0,-2) then for j,receive_info in ipairs(state.tracksReceives[track_idx]) do imgui.Text(ctx,"Receive "..j..": <- From "..receive_info.src_track_name) if receive_info.mute==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0,0,0.5)) end if imgui.Button(ctx,"Mute##receive"..j..track_idx,50,0) then reaper.SetTrackSendInfo_Value(receive_info.src_track,0,receive_info.send_idx,"B_MUTE",1-receive_info.mute); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Toggle Receive Mute",-1) end if receive_info.mute==1 then imgui.PopStyleColor(ctx) end ShowTooltip("Mute/Unmute this receive.") imgui.SameLine(ctx,0,10); imgui.PushItemWidth(ctx,-125) local db,db_int_val=GainToDB(receive_info.vol),math.floor(GainToDB(receive_info.vol)+0.5) local vol_changed,new_db_int=imgui.SliderInt(ctx,"##vol_receive"..j..track_idx,db_int_val,-100,12,"") ShowTooltip(string.format("Volume: %.2f dB\nDouble-click or right-click to reset to 0dB.",db)) if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetTrackSendInfo_Value(receive_info.src_track,0,receive_info.send_idx,"D_VOL",1) elseif vol_changed then reaper.SetTrackSendInfo_Value(receive_info.src_track,0,receive_info.send_idx,"D_VOL",DBToGain(new_db_int)); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Receive Volume",-1) end imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("Vol: %.1f dB",db)) imgui.PushItemWidth(ctx,-80) local pan_val=math.floor(receive_info.pan*100+0.5) local pan_changed,new_pan_int=imgui.SliderInt(ctx,"##pan_receive"..j..track_idx,pan_val,-100,100,"Pan: %d") ShowTooltip("Double-click or right-click to reset to center.") if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetTrackSendInfo_Value(receive_info.src_track,0,receive_info.send_idx,"D_PAN",0) elseif pan_changed then reaper.SetTrackSendInfo_Value(receive_info.src_track,0,receive_info.send_idx,"D_PAN",new_pan_int/100); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Receive Pan",-1) end imgui.PopItemWidth(ctx); imgui.Separator(ctx) end end imgui.EndChild(ctx) else imgui.Text(ctx,"Select a track from the list on the left to edit its receives.") end imgui.EndTable(ctx) end elseif state.edit_mode=="CHAN STRIP" then local track_idx=state.last_selected_track_idx if track_idx and state.tracks[track_idx] then local track=state.tracks[track_idx] local guid_str=reaper.GetTrackGUID(track) local _,name=reaper.GetTrackName(track) local r,g,b=reaper.ColorFromNative(reaper.GetTrackColor(track)) if imgui.BeginTable(ctx,"ChannelStripLayout",2,0) then imgui.TableSetupColumn(ctx,"Controls",imgui.TableColumnFlags_WidthStretch) imgui.TableSetupColumn(ctx,"FaderMeter",imgui.TableColumnFlags_WidthFixed,120) imgui.TableNextColumn(ctx) local left_col_start_y=imgui.GetCursorPosY(ctx) imgui.PushStyleColor(ctx,imgui.Col_Text,PackColor(r/255,g/255,b/255,1.0)) imgui.Text(ctx,string.format("CHANNEL: %02d: %s",track_idx,name)) imgui.PopStyleColor(ctx) local content_avail=imgui.GetContentRegionAvail(ctx) local content_w=type(content_avail)=='table' and content_avail.x or content_avail local btn_w=25 local btn_h=25 local btn_spacing=8 local total_btns_w=(btn_w*4)+(btn_spacing*3) imgui.SameLine(ctx,content_w-total_btns_w-5) imgui.BeginGroup(ctx) if state.tracksPhase[track_idx]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0.5,0,0.5)) end; if imgui.Button(ctx,"ø##phase_cs",btn_w,btn_h) then reaper.SetMediaTrackInfo_Value(track,"B_PHASE",1-state.tracksPhase[track_idx]) end; if state.tracksPhase[track_idx]==1 then imgui.PopStyleColor(ctx) end; ShowTooltip("Invert Phase"); imgui.SameLine(ctx) if state.tracksMut[track_idx]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0,0,0.5)) end; if imgui.Button(ctx,"M##mute_cs",btn_w,btn_h) then reaper.SetMediaTrackInfo_Value(track,"B_MUTE",1-state.tracksMut[track_idx]) end; if state.tracksMut[track_idx]==1 then imgui.PopStyleColor(ctx) end; ShowTooltip("Mute"); imgui.SameLine(ctx) if state.tracksSol[track_idx]>0 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,1,0,0.5)) end; if imgui.Button(ctx,"S##solo_cs",btn_w,btn_h) then reaper.SetMediaTrackInfo_Value(track,"I_SOLO",state.tracksSol[track_idx]>0 and 0 or 1) end; if state.tracksSol[track_idx]>0 then imgui.PopStyleColor(ctx) end; ShowTooltip("Solo"); imgui.SameLine(ctx) if state.tracksFX[track_idx]~=-1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(0,1,0,0.5)) end; if imgui.Button(ctx,"FX##fx_cs",btn_w,btn_h) then reaper.TrackFX_Show(track,0,state.tracksFX[track_idx]==-1 and 1 or -1) end; if state.tracksFX[track_idx]~=-1 then imgui.PopStyleColor(ctx) end; ShowTooltip("Open FX Chain window") imgui.EndGroup(ctx) imgui.Separator(ctx) imgui.Text(ctx,"Pan"); imgui.SameLine(ctx); imgui.PushItemWidth(ctx,-1) local pan_val=math.floor(state.tracksPan[track_idx]*100+0.5) local pan_changed,new_pan=imgui.SliderInt(ctx,"##Pan_cs",pan_val,-100,100,"%d") ShowTooltip("Pan (Left/Right Balance)\nDouble-click or right-click to reset.") if pan_changed then reaper.SetMediaTrackInfo_Value(track,"D_PAN",new_pan/100); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Pan",-1) end if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_PAN",0) end imgui.PopItemWidth(ctx) imgui.Text(ctx,"Width"); imgui.SameLine(ctx); imgui.PushItemWidth(ctx,-1) local width_val=math.floor(state.tracksWidth[track_idx]*100+0.5) local width_changed,new_width=imgui.SliderInt(ctx,"##Width_cs",width_val,-100,100,"%d%%") ShowTooltip("Stereo Width\nDouble-click or right-click to reset.") if width_changed then reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",new_width/100); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Width",-1) end if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",1) end imgui.PopItemWidth(ctx) imgui.Separator(ctx) imgui.Text(ctx,"QUICK COMP") if state.quickControls.reaComp_idx then local comp_fx=state.quickControls.reaComp_idx if imgui.Button(ctx,(state.quickControls.reaComp_params.bypass and "Bypassed" or "Bypass").."##Comp_Bypass") then reaper.TrackFX_SetEnabled(track,comp_fx,not state.quickControls.reaComp_params.bypass) end ShowTooltip("Enable/Disable ReaComp.") local function CompSlider(label,param_idx,slider_min,slider_max,format) local norm_val=reaper.TrackFX_GetParam(track,comp_fx,param_idx) local _,formatted_val=reaper.TrackFX_GetFormattedParamValue(track,comp_fx,param_idx,norm_val,"") local slider_val=math.floor(norm_val*(slider_max-slider_min)+slider_min+0.5) imgui.Text(ctx,label..": "..formatted_val); imgui.SameLine(ctx); imgui.PushItemWidth(ctx,-1) local changed,new_slider_val=imgui.SliderInt(ctx,"##"..label,slider_val,slider_min,slider_max,"") ShowTooltip(label.." - ReaComp") if changed then local new_norm_val=(new_slider_val-slider_min)/(slider_max-slider_min) reaper.TrackFX_SetParam(track,comp_fx,param_idx,new_norm_val) end imgui.PopItemWidth(ctx) end CompSlider("Threshold",0,0,1000) CompSlider("Ratio",1,0,1000) CompSlider("Pre-comp",4,0,1000) CompSlider("Attack",2,0,1000) CompSlider("Release",3,0,1000) else imgui.Text(ctx,"ReaComp not found on this track.") end imgui.Separator(ctx) imgui.Text(ctx,"Sends") if #state.tracksSends[track_idx]>0 then for j=1,math.min(4,#state.tracksSends[track_idx]) do local send_info=state.tracksSends[track_idx][j] local send_api_idx=j-1 imgui.Text(ctx,"S"..j.." -> "..send_info.dest_track_name) imgui.PushItemWidth(ctx,-1) local db,db_int_val=GainToDB(send_info.vol),math.floor(GainToDB(send_info.vol)+0.5) local vol_changed,new_db_int=imgui.SliderInt(ctx,"##vol_send_cs"..j,db_int_val,-100,12,string.format("%.1f dB",db)) ShowTooltip(string.format("Send Volume: %.2f dB\nDouble-click or right-click to reset.",db)) if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetTrackSendInfo_Value(track,0,send_api_idx,"D_VOL",1) elseif vol_changed then reaper.SetTrackSendInfo_Value(track,0,send_api_idx,"D_VOL",DBToGain(new_db_int)); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Send Volume",-1) end imgui.PopItemWidth(ctx) end else imgui.Text(ctx,"No Sends on this track.") end imgui.Separator(ctx) imgui.Text(ctx,"Pinned FX Parameters") if state.pinnedParams[guid_str] and #state.pinnedParams[guid_str]>0 then for p_idx,param_info in ipairs(state.pinnedParams[guid_str]) do local _,param_name=reaper.TrackFX_GetParamName(track,param_info.fx_idx,param_info.param_idx,"") local _,formatted_val=reaper.TrackFX_GetFormattedParamValue(track,param_info.fx_idx,param_info.param_idx,"") imgui.PushItemWidth(ctx,-65) local norm_val=reaper.TrackFX_GetParam(track,param_info.fx_idx,param_info.param_idx) local slider_val=math.floor(norm_val*1000+0.5) local changed,new_slider_val=imgui.SliderInt(ctx,"##fxparam_cs"..p_idx,slider_val,0,1000,param_name) ShowTooltip(param_name) if changed then reaper.TrackFX_SetParam(track,param_info.fx_idx,param_info.param_idx,new_slider_val/1000.0); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust FX Parameter",-1) end imgui.PopItemWidth(ctx) imgui.SameLine(ctx,0,5) imgui.Text(ctx,formatted_val) end else imgui.Text(ctx,"No Pinned FX on this track.") end local left_col_end_y=imgui.GetCursorPosY(ctx) local left_col_height=left_col_end_y-left_col_start_y imgui.TableNextColumn(ctx) local text_height=22 local element_height=left_col_height-text_height if element_height<50 then element_height=50 end imgui.BeginGroup(ctx) local db=GainToDB(state.tracksVol[track_idx]) local s_val if db>=0 then s_val=(db/12)*100 else s_val=(db/60)*100 end s_val=math.floor(s_val+0.5) local fader_changed,new_s=imgui.VSliderInt(ctx,"##Vol_cs",40,element_height,s_val,-100,100,"") ShowTooltip(string.format("Volume: %.2f dB\nDouble-click or right-click to reset to 0dB.",db)) if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_VOL",1); fader_changed=false end if fader_changed then local new_db if new_s>=0 then new_db=(new_s/100)*12 else new_db=(new_s/100)*60 end reaper.SetMediaTrackInfo_Value(track,"D_VOL",DBToGain(new_db)) reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust Vol",-1) end local db_text=string.format("%.1f dB",db) local text_w=imgui.CalcTextSize(ctx,db_text) imgui.SetCursorPosX(ctx,imgui.GetCursorPosX(ctx)+(40-text_w)/2) imgui.Text(ctx,db_text) imgui.EndGroup(ctx) imgui.SameLine(ctx,0,5) DrawVUMeter(ctx,element_height,state.tracksPeakL[track_idx],state.tracksPeakR[track_idx],state.tracksPeakHoldL[track_idx],state.tracksPeakHoldR[track_idx],track_idx) imgui.EndTable(ctx) end else imgui.Text(ctx,"Please select a track in REAPER to use Channel Strip View.") end else if imgui.BeginTable(ctx,'MainMixerArea',2,imgui.TableFlags_BordersInnerV+imgui.TableFlags_Resizable) then imgui.TableSetupColumn(ctx,"Tracks",imgui.TableColumnFlags_WidthFixed,260) imgui.TableSetupColumn(ctx,"Controls",imgui.TableColumnFlags_WidthStretch) local hide_children_of_collapsed_folder,collapsed_folder_depth=false,-1 for i=1,#state.tracks do local track=state.tracks[i] if reaper.ValidatePtr(track,"MediaTrack*") then local current_depth=state.tracksDepth[i] if hide_children_of_collapsed_folder and current_depth>collapsed_folder_depth then goto continue_loop elseif hide_children_of_collapsed_folder and current_depth<=collapsed_folder_depth then hide_children_of_collapsed_folder,collapsed_folder_depth=false,-1 end local guid_str=reaper.GetTrackGUID(track) local _,name=reaper.GetTrackName(track) local show_track=true if not(state.filter_text=="" or string.find(string.lower(name),string.lower(state.filter_text),1,true)) then show_track=false end if show_track and not ApplyViewFilter(i) then show_track=false end if show_track and state.edit_mode=="FX PARAMS" and(not state.pinnedParams[guid_str] or #state.pinnedParams[guid_str]==0) then show_track=false end if show_track then imgui.TableNextColumn(ctx) if current_depth>0 then imgui.Indent(ctx,current_depth*config.indent_size) end if imgui.BeginTable(ctx,'track_line'..i,3,0) then imgui.TableSetupColumn(ctx,'vis'..i,imgui.TableColumnFlags_WidthFixed,25) imgui.TableSetupColumn(ctx,'name'..i,imgui.TableColumnFlags_WidthStretch) imgui.TableSetupColumn(ctx,'buttons'..i,imgui.TableColumnFlags_WidthFixed,140) imgui.TableNextColumn(ctx) if not state.tracksVisible[i] then imgui.PushStyleColor(ctx,imgui.Col_Text,PackColor(0.6,0.6,0.6,1.0)) end if imgui.Button(ctx,"👁##vis"..i,20,0) then local new_vis_state=state.tracksVisible[i] and 0 or 1; reaper.SetMediaTrackInfo_Value(track,"B_SHOWINTCP",new_vis_state); reaper.SetMediaTrackInfo_Value(track,"B_SHOWINMIXER",new_vis_state); ForceUIRefresh() end ShowTooltip("Show/Hide this track in TCP and Mixer.") if not state.tracksVisible[i] then imgui.PopStyleColor(ctx) end imgui.TableNextColumn(ctx) local display_name=string.format("%02d: %s",i,name) if state.isFolder[i] then display_name=(state.folderCollapsed[i] and "📂 " or "📁 ")..display_name end local r,g,b=reaper.ColorFromNative(reaper.GetTrackColor(track)) imgui.PushStyleColor(ctx,imgui.Col_Header,PackColor(r/255,g/255,b/255,0.3)); imgui.PushStyleColor(ctx,imgui.Col_HeaderHovered,PackColor(r/255,g/255,b/255,0.5)); imgui.PushStyleColor(ctx,imgui.Col_HeaderActive,PackColor(r/255,g/255,b/255,0.7)) if imgui.Selectable(ctx,display_name,state.tracksSel[i]) then reaper.SetTrackSelected(track,not state.tracksSel[i]) if has_sws_set_last_touched then reaper.SetLastTouchedTrack(track) end end ShowTooltip("Click to select/deselect track.\nDouble-click a folder (📂/📁) to collapse/expand.") if imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0) and state.isFolder[i] then state.folderCollapsed[i]=not state.folderCollapsed[i] end imgui.PopStyleColor(ctx,3) if imgui.BeginPopupContextItem(ctx,"TrackContextPopup") then if imgui.MenuItem(ctx,'Insert New Track') then reaper.defer(function() reaper.Main_OnCommand(40001,0) end) end; imgui.Separator(ctx) if imgui.MenuItem(ctx,'Rename Track') then local _,old_name=reaper.GetTrackName(track); local ok,new_name=reaper.GetUserInputs("Rename Track",1,"New Name:",old_name); if ok and new_name~="" then reaper.GetSetMediaTrackInfo_String(track,"P_NAME",new_name,true) end end if imgui.MenuItem(ctx,'Delete Track') then reaper.defer(function() reaper.DeleteTrack(track) end) end imgui.EndPopup(ctx) end imgui.TableNextColumn(ctx) if state.tracksMut[i]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0,0,0.5)) end; if imgui.Button(ctx,"M##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"B_MUTE",1-state.tracksMut[i]) end; if state.tracksMut[i]==1 then imgui.PopStyleColor(ctx) end; ShowTooltip("Mute"); imgui.SameLine(ctx,0,2) if state.tracksSol[i]>0 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,1,0,0.5)) end; if imgui.Button(ctx,"S##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"I_SOLO",state.tracksSol[i]>0 and 0 or 1) end; if state.tracksSol[i]>0 then imgui.PopStyleColor(ctx) end; ShowTooltip("Solo"); imgui.SameLine(ctx,0,2) if state.tracksFX[i]~=-1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(0,1,0,0.5)) end; if imgui.Button(ctx,"FX##"..i,20,0) then reaper.TrackFX_Show(track,0,state.tracksFX[i]==-1 and 1 or -1) end; if state.tracksFX[i]~=-1 then imgui.PopStyleColor(ctx) end; ShowTooltip("Open FX Chain window"); imgui.SameLine(ctx,0,2) if state.tracksPhase[i]==1 then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(1,0.5,0,0.5)) end; if imgui.Button(ctx,"ø##"..i,20,0) then reaper.SetMediaTrackInfo_Value(track,"B_PHASE",1-state.tracksPhase[i]) end; if state.tracksPhase[i]==1 then imgui.PopStyleColor(ctx) end; ShowTooltip("Invert Phase"); imgui.SameLine(ctx,0,2) local has_pins=state.pinnedParams[guid_str] and #state.pinnedParams[guid_str]>0 if has_pins then imgui.PushStyleColor(ctx,imgui.Col_Button,PackColor(0.2,0.6,1.0,0.7)) end if imgui.Button(ctx,"Pin##pin"..i,25,0) then state.popup_pin_track_idx=i; state.open_pin_popup=true end ShowTooltip("Pin an FX parameter from this track\nfor quick control in 'FX PARAMS' mode.") if has_pins then imgui.PopStyleColor(ctx) end imgui.EndTable(ctx) end if current_depth>0 then imgui.Unindent(ctx,current_depth*config.indent_size) end imgui.TableNextColumn(ctx) if state.edit_mode=="PAN" then local pan_val=math.floor(state.tracksPan[i]*100+0.5) imgui.PushItemWidth(ctx,-50); local changed,new_pan=imgui.SliderInt(ctx,"##Pan"..i,pan_val,-100,100,""); imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("%d",pan_val)) ShowTooltip("Double-click or right-click to reset to center.") if changed then reaper.Undo_BeginBlock();local d=new_pan/100-state.tracksPan[i];if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];local p=reaper.GetMediaTrackInfo_Value(t,"D_PAN")+d;reaper.SetMediaTrackInfo_Value(t,"D_PAN",math.max(-1,math.min(1,p))) end end else reaper.SetMediaTrackInfo_Value(track,"D_PAN",new_pan/100) end; reaper.Undo_EndBlock("Adjust Pan",-1) end if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_PAN",0) end elseif state.edit_mode=="VOL" then local db=GainToDB(state.tracksVol[i]) local s_val if db>=0 then s_val=(db/12)*100 else s_val=(db/60)*100 end s_val=math.floor(s_val+0.5) imgui.PushItemWidth(ctx,-60);local ch,new_s=imgui.SliderInt(ctx,"##Vol"..i,s_val,-100,100,"");imgui.PopItemWidth(ctx);imgui.SameLine(ctx,0,5);imgui.Text(ctx,string.format("%.1f dB",db)) ShowTooltip(string.format("Volume: %.2f dB\nDouble-click or right-click to reset to 0dB.",db)) if ch then reaper.Undo_BeginBlock() local new_db if new_s>=0 then new_db=(new_s/100)*12 else new_db=(new_s/100)*60 end if state.tracksSel[i] then local old_gain=state.tracksVol[i] local new_gain=DBToGain(new_db) local ratio=(old_gain>0.000001) and(new_gain/old_gain) or 1 for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j]; local current_gain=reaper.GetMediaTrackInfo_Value(t,"D_VOL") reaper.SetMediaTrackInfo_Value(t,"D_VOL",current_gain*ratio) end end else reaper.SetMediaTrackInfo_Value(track,"D_VOL",DBToGain(new_db)) end; reaper.Undo_EndBlock("Adjust Vol",-1) end if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_VOL",1) end elseif state.edit_mode=="WIDTH" then local width_val=math.floor(state.tracksWidth[i]*100+0.5) imgui.PushItemWidth(ctx,-50); local changed,new_width_int=imgui.SliderInt(ctx,"##Width"..i,width_val,-100,100,""); imgui.PopItemWidth(ctx); imgui.SameLine(ctx,0,5); imgui.Text(ctx,string.format("%d%%",width_val)) ShowTooltip("Double-click or right-click to reset to 100%.") if changed then reaper.Undo_BeginBlock();local new_width=new_width_int/100.0;local d=new_width-state.tracksWidth[i];if state.tracksSel[i] then for j=1,#state.tracks do if state.tracksSel[j] then local t=state.tracks[j];local w=reaper.GetMediaTrackInfo_Value(t,"D_WIDTH")+d;reaper.SetMediaTrackInfo_Value(t,"D_WIDTH",math.max(-1,math.min(1,w))) end end else reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",new_width) end; reaper.Undo_EndBlock("Adjust Width",-1) end if imgui.IsItemClicked(ctx,1) or(imgui.IsItemHovered(ctx) and imgui.IsMouseDoubleClicked(ctx,0)) then reaper.SetMediaTrackInfo_Value(track,"D_WIDTH",1) end elseif state.edit_mode=="FX PARAMS" then if state.pinnedParams[guid_str] then for p_idx,param_info in ipairs(state.pinnedParams[guid_str]) do if imgui.Button(ctx,"X##unpin"..i..p_idx,20,0) then table.remove(state.pinnedParams[guid_str],p_idx); save_pinned_params(); goto continue_fx_loop end ShowTooltip("Unpin this parameter.") imgui.SameLine(ctx) local _,param_name=reaper.TrackFX_GetParamName(track,param_info.fx_idx,param_info.param_idx,"") local _,formatted_val=reaper.TrackFX_GetFormattedParamValue(track,param_info.fx_idx,param_info.param_idx,"") imgui.PushItemWidth(ctx,-65) local norm_val=reaper.TrackFX_GetParam(track,param_info.fx_idx,param_info.param_idx) local slider_val=math.floor(norm_val*1000+0.5) local changed,new_slider_val=imgui.SliderInt(ctx,"##fxparam"..i..p_idx,slider_val,0,1000,param_name) ShowTooltip(param_name) if changed then reaper.TrackFX_SetParam(track,param_info.fx_idx,param_info.param_idx,new_slider_val/1000.0); reaper.Undo_BeginBlock(); reaper.Undo_EndBlock("Adjust FX Parameter",-1) end imgui.PopItemWidth(ctx) imgui.SameLine(ctx,0,5) imgui.Text(ctx,formatted_val) ::continue_fx_loop:: end end end if state.isFolder[i] and state.folderCollapsed[i] then hide_children_of_collapsed_folder,collapsed_folder_depth=true,current_depth end end end ::continue_loop:: end imgui.EndTable(ctx) end end if state.open_pin_popup then imgui.OpenPopup(ctx,"PinFXParamPopup") state.open_pin_popup=false end if imgui.BeginPopup(ctx,"PinFXParamPopup") then if state.popup_pin_track_idx then local track=state.tracks[state.popup_pin_track_idx] local _,track_name=reaper.GetTrackName(track) imgui.Text(ctx,"Pin Parameter for: "..track_name); imgui.Separator(ctx) local fx_count=reaper.TrackFX_GetCount(track) if fx_count>0 then for fx=0,fx_count-1 do local _,fx_name=reaper.TrackFX_GetFXName(track,fx,"") if imgui.TreeNode(ctx,fx_name.."##fxnode"..fx) then local param_count=reaper.TrackFX_GetNumParams(track,fx) for p=0,param_count-1 do local _,param_name=reaper.TrackFX_GetParamName(track,fx,p,"") if imgui.Selectable(ctx,param_name.."##param"..p) then local guid_str=reaper.GetTrackGUID(track) local new_pin={fx_idx=fx,param_idx=p} if not state.pinnedParams[guid_str] then state.pinnedParams[guid_str]={} end local exists=false for _,pin in ipairs(state.pinnedParams[guid_str]) do if pin.fx_idx==new_pin.fx_idx and pin.param_idx==new_pin.param_idx then exists=true; break end end if not exists then table.insert(state.pinnedParams[guid_str],new_pin) save_pinned_params() end state.popup_pin_track_idx=nil imgui.CloseCurrentPopup(ctx) end end imgui.TreePop(ctx) end end else imgui.Text(ctx,"No FX on this track.") end imgui.Separator(ctx) if imgui.Button(ctx,"Close") then state.popup_pin_track_idx=nil imgui.CloseCurrentPopup(ctx) end end imgui.EndPopup(ctx) end if state.open_custom_menu_config then imgui.OpenPopup(ctx,"Configure Custom Menu") state.open_custom_menu_config=false end imgui.SetNextWindowSize(ctx,500,450,imgui.Cond_FirstUseEver) if imgui.BeginPopupModal(ctx,"Configure Custom Menu") then imgui.Text(ctx,"Manage Custom Menu (Drag & drop to reorder)"); imgui.Separator(ctx) if imgui.Button(ctx,"Add to Root") then state.menu_config_target_table=state.customMenu end imgui.SameLine(ctx) imgui.TextDisabled(ctx,"(Click a sub-menu in the tree to select it as the target)") if imgui.BeginChild(ctx,"MenuTree",0,-150) then DrawMenuConfiguration(state.customMenu,"") end imgui.EndChild(ctx) if state.dnd_source_path and state.dnd_target_path then execute_menu_move(state.dnd_source_path,state.dnd_target_path,state.dnd_drop_type) state.dnd_source_path,state.dnd_target_path,state.dnd_drop_type=nil,nil,nil elseif state.item_to_delete_path then execute_menu_delete(state.item_to_delete_path) state.item_to_delete_path=nil end imgui.Separator(ctx) imgui.Text(ctx,"Add New Item") local label_col_width=150 imgui.Text(ctx,"Type") imgui.SameLine(ctx,label_col_width) imgui.PushItemWidth(ctx,-1) local item_types="Action\0Sub-menu\0Separator\0" local type_changed,new_type=imgui.Combo(ctx,"##ItemType",state.new_menu_item_type_idx,item_types) if type_changed then state.new_menu_item_type_idx=new_type state.new_menu_item_name="" state.new_menu_item_id="" end imgui.PopItemWidth(ctx) if state.new_menu_item_type_idx~=2 then imgui.Text(ctx,"Display Name") imgui.SameLine(ctx,label_col_width) imgui.PushItemWidth(ctx,-1) local name_changed,new_name=imgui.InputText(ctx,"##DisplayName",state.new_menu_item_name,128) if name_changed then state.new_menu_item_name=new_name end imgui.PopItemWidth(ctx) end if state.new_menu_item_type_idx==0 then imgui.Text(ctx,"Command ID / Script ID") imgui.SameLine(ctx,label_col_width) imgui.PushItemWidth(ctx,-1) local id_changed,new_id=imgui.InputText(ctx,"##CommandID",state.new_menu_item_id,256) if id_changed then state.new_menu_item_id=new_id end imgui.PopItemWidth(ctx) ShowTooltip("Enter the Action ID (e.g., 40001) or the script/extension ID (e.g., _RS123abc...).") end if imgui.Button(ctx,"Add Item",120,0) then local target=state.menu_config_target_table or state.customMenu local changed=false if state.new_menu_item_type_idx==0 then if state.new_menu_item_name~="" and state.new_menu_item_id~="" then table.insert(target,{type="item",name=state.new_menu_item_name,commandId=state.new_menu_item_id}) changed=true end elseif state.new_menu_item_type_idx==1 then if state.new_menu_item_name~="" then table.insert(target,{type="menu",name=state.new_menu_item_name,items={}}) changed=true end elseif state.new_menu_item_type_idx==2 then table.insert(target,{type="separator",name="---"}) changed=true end if changed then save_custom_menu() state.new_menu_item_name="" state.new_menu_item_id="" end end imgui.SameLine(ctx,imgui.GetWindowWidth(ctx)-110) if imgui.Button(ctx,"Close",100,0) then imgui.CloseCurrentPopup(ctx) end imgui.EndPopup(ctx) end imgui.End(ctx) end if state.is_open then reaper.defer(loop) end end function Main() load_pinned_params() load_custom_menu() update_and_check_tracks() loop() end reaper.defer(Main)

