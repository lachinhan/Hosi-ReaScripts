--[[
@description Hosi Variator - Sound Design Edition
@author      Hosi
@version     2.0
@about
  SOUND DESIGN EDITION
  This script is a powerful Texture Morphing and Randomization tool for Sound Design.
  
  Features:
  - Tape Mode: Link Rate & Pitch for organic varispeed effects.
  - Layering Control: Precise control over Start Offset and Free Mode positioning.
  - Texture Tools: Reverse probability, Formant shifting (future), and more.
  - Modern Dark UI: Professional interface with preset management.

  Instructions:
  1. Select media items.
  2. Configure randomization parameters in the tabs.
  3. Use "Global Chaos" to scale the overall intensity.
  4. Click "Mutate" to process.
--]]
package.path=reaper.ImGui_GetBuiltinPath()..'/?.lua' local lIlIlIl=require('imgui')('0.10') if not lIlIlIl or type(lIlIlIl)~="table" then reaper.MB("Failed to initialize ReaImGui library. Please ensure it is installed and up to date via ReaPack.","Hosi Variator Error",0) return end local lIllIlI=lIlIlIl.CreateContext('Hosi Variator') local lIIllIl=true local lIlIIlI=reaper.GetCursorPosition() local lIIlIlI=reaper.GetResourcePath()..'/Hosi_Variator_Presets.lua' local lIlllIl=100 local lIlIlll=false local lIIlllI=true local lIllIIl={WindowBg=0x1E1E24FF,ChildBg=0x25252DFF,PopupBg=0x25252DFF,Text=0xE0E0E0FF,TextDisabled=0x808080FF,Border=0x44444CFF,FrameBg=0x363640FF,FrameBgHover=0x4A4A55FF,FrameBgActive=0x5A5A65FF,TitleBg=0x15151AFF,Button=0x5C6BC0AA,ButtonHover=0x5C6BC0FF,ButtonActive=0x3F51B5FF,Header=0x363640FF,HeaderHover=0x4A4A55FF,HeaderActive=0x5A5A65FF,ResizeGrip=0x5C6BC044,CheckMark=0x8C9EFFFF,Separator=0x44444CFF,PlotLines=0x8C9EFFFF,PlotFull=0x8C9EFF44} local lIlIlII={WindowRounding=10.0,ChildRounding=8.0,FrameRounding=5.0,GrabRounding=5.0,PopupRounding=5.0,ScrollbarRounding=12.0,TabRounding=6.0,ItemSpacingX=8.0,ItemSpacingY=4.0} function lIIlIII(lIllIlI) local lIIIlIl=0 local lIllIllI=0 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_WindowBg,lIllIIl.WindowBg); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_ChildBg,lIllIIl.ChildBg); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_PopupBg,lIllIIl.PopupBg); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_Text,lIllIIl.Text); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_TextDisabled,lIllIIl.TextDisabled); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_Border,lIllIIl.Border); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_FrameBg,lIllIIl.FrameBg); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_FrameBgHovered,lIllIIl.FrameBgHover); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_FrameBgActive,lIllIIl.FrameBgActive); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_TitleBg,lIllIIl.TitleBg); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_Button,lIllIIl.Button); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_ButtonHovered,lIllIIl.ButtonHover); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_ButtonActive,lIllIIl.ButtonActive); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_Header,lIllIIl.Header); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_HeaderHovered,lIllIIl.HeaderHover); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_HeaderActive,lIllIIl.HeaderActive); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_Separator,lIllIIl.Separator); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_ResizeGrip,lIllIIl.ResizeGrip); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_CheckMark,lIllIIl.CheckMark); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_PlotLines,lIllIIl.PlotLines); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleColor(lIllIlI,lIlIlIl.Col_PlotHistogram,lIllIIl.PlotLines); lIIIlIl=lIIIlIl+1 lIlIlIl.PushStyleVar(lIllIlI,lIlIlIl.StyleVar_WindowRounding,lIlIlII.WindowRounding); lIllIllI=lIllIllI+1 lIlIlIl.PushStyleVar(lIllIlI,lIlIlIl.StyleVar_ChildRounding,lIlIlII.ChildRounding); lIllIllI=lIllIllI+1 lIlIlIl.PushStyleVar(lIllIlI,lIlIlIl.StyleVar_FrameRounding,lIlIlII.FrameRounding); lIllIllI=lIllIllI+1 lIlIlIl.PushStyleVar(lIllIlI,lIlIlIl.StyleVar_PopupRounding,lIlIlII.PopupRounding); lIllIllI=lIllIllI+1 lIlIlIl.PushStyleVar(lIllIlI,lIlIlIl.StyleVar_GrabRounding,lIlIlII.GrabRounding); lIllIllI=lIllIllI+1 lIlIlIl.PushStyleVar(lIllIlI,lIlIlIl.StyleVar_TabRounding,lIlIlII.TabRounding); lIllIllI=lIllIllI+1 lIlIlIl.PushStyleVar(lIllIlI,lIlIlIl.StyleVar_ItemSpacing,lIlIlII.ItemSpacingX,lIlIlII.ItemSpacingY); lIllIllI=lIllIllI+1 return lIIIlIl,lIllIllI end function lIllIll(min,max) if min>max then min,max=max,min end return math.random()*(max-min)+min end function lIlIIll(min,max,bias) local range=max-min local value=min+math.random()*range if bias~=0 then local biased_factor=(bias/100)*range/2 value=value+biased_factor end return math.min(max,math.max(min,value)) end function lIIlIlll(min,max,bias) local u1,u2=math.random(),math.random() local z=math.sqrt(-2*math.log(u1))*math.cos(2*math.pi*u2) local mean=(min+max)/2 local std_dev=(max-min)/6 local value=z*std_dev+mean if bias~=0 then local biased_factor=(bias/100)*std_dev value=value+biased_factor end return math.min(max,math.max(min,value)) end function lIllIlIl(min,max,bias) local value=min-(max-min)*math.log(1-math.random()) if bias~=0 then local range=max-min local biased_factor=(bias/100)*range/2 value=value+biased_factor end return math.min(max,math.max(min,value)) end function lIlIlIll(min,max,curve_type,bias) if curve_type=="Bell Curve" then return lIIlIlll(min,max,bias) elseif curve_type=="Exponential" then return lIllIlIl(min,max,bias) else return lIlIIll(min,max,bias) end end local lIIllII={{key="pitch",label="Pitch",tab="Core",enabled=true,amount=20,bias=0,type="float",base=0,range=12.0,curve="Linear",tooltip="Randomize pitch shift in semitones."},{key="rate",label="Play Rate",tab="Core",enabled=true,amount=20,bias=0,type="float",base=1.0,range=0.5,curve="Linear",tooltip="Randomize playback rate.\nAffects item length and pitch (if Tape Mode is ON)."},{key="vol",label="Volume",tab="Core",enabled=true,amount=50,bias=0,type="float",base=0,range=12.0,curve="Linear",tooltip="Randomize item volume gain (dB)."},{key="pan",label="Pan",tab="Core",enabled=true,amount=100,bias=0,type="float",base=0,range=1.0,curve="Linear",tooltip="Randomize stereo panning (Left/Right)."},{key="pos",label="Position (Smear)",tab="Space",enabled=true,amount=10,bias=0,type="float",base=0,range=0.5,curve="Linear",tooltip="Randomize item start position on the timeline.\nUseful for creating 'sloppy' or organic timing."},{key="start_offs",label="Start Offset",tab="Space",enabled=false,amount=50,bias=0,type="float",base=0,range=1.0,curve="Linear",tooltip="Slip-edit the media content within the item.\nGreat for varying the phase of layered sounds."},{key="fm_y",label="Free Mode Y",tab="Space",enabled=false,amount=0,bias=0,type="float",base=0,range=1.0,curve="Linear",tooltip="Vertical position in Free Item Positioning Mode.\n0 = Top, 1 = Bottom."},{key="fm_h",label="Free Mode H",tab="Space",enabled=false,amount=0,bias=0,type="float",base=0,range=1.0,curve="Linear",tooltip="Item Height in Free Item Positioning Mode.\n0 = Thin, 1 = Full Height."},{key="drift_depth",label="Drift Depth",tab="Texture",enabled=false,amount=0,bias=0,type="float",base=0,range=1.0,curve="Linear",tooltip="Max pitch deviation (semitones).\nCreates tape 'wow & flutter' or analog instability."},{key="drift_rate",label="Drift Speed",tab="Texture",enabled=false,amount=50,bias=0,type="float",base=0.5,range=8.0,curve="Linear",tooltip="Frequency of pitch modulation (Hz).\nHigher = faster wobble."},{key="formant",label="Formant Shift",tab="Texture",enabled=false,amount=50,bias=0,type="float",base=0,range=12.0,curve="Linear",tooltip="Shifts the sonic characteristic (timber) without changing the pitch.\nUses 'ReaPitch' plugin."},{key="reverse",label="Reverse Chance",tab="Texture",enabled=false,amount=0,bias=0,type="int",base=0,range=100,curve="Linear",tooltip="Probability (%) that an item will be reversed.\nCreates interesting textural variations."},{key="fade_in",label="Fade In Len",tab="Texture",enabled=false,amount=50,bias=0,type="float",base=0,range=0.1,curve="Linear",tooltip="Randomize Fade-In length."},{key="fade_out",label="Fade Out Len",tab="Texture",enabled=false,amount=50,bias=0,type="float",base=0,range=0.1,curve="Linear",tooltip="Randomize Fade-Out length."},{key="shape_in",label="Fade In Shape",tab="Texture",enabled=false,amount=100,bias=0,type="int",base=0,range=6,curve="Linear",tooltip="Randomize Fade-In curve shape."},{key="shape_out",label="Fade Out Shape",tab="Texture",enabled=false,amount=100,bias=0,type="int",base=0,range=6,curve="Linear",tooltip="Randomize Fade-Out curve shape."},{key="slice_prob",label="Slice Chance",tab="Glitch",enabled=false,amount=0,bias=0,type="int",base=0,range=100,curve="Linear",tooltip="Probability that a slice will occur at each grid point."},{key="slice_grid",label="Slice Grid",tab="Glitch",enabled=false,amount=0,bias=0,type="int",base=0,range=4,curve="Linear",tooltip="Grid Size: 0=1/4, 1=1/8, 2=1/16, 3=1/32, 4=1/64"},{key="warp_dens",label="Warp Density",tab="Glitch",enabled=false,amount=20,bias=0,type="int",base=1,range=10,curve="Linear",tooltip="Number of Stretch Markers to insert.\nMore markers = more fluid/complex warping."},{key="warp_depth",label="Warp Depth",tab="Glitch",enabled=false,amount=30,bias=0,type="float",base=0,range=0.2,curve="Linear",tooltip="Max timing deviation (seconds) for each marker.\nCreates the 'Liquid/Elastic' time-stretching effect."},{key="chaos_dist",label="Distortion",tab="Chaos",enabled=false,amount=50,bias=0,type="float",base=0,range=100,curve="Linear",tooltip="Add random Saturation/Grit.\nUses 'JS: Saturation'."},{key="chaos_filt",label="Filter Sweep",tab="Chaos",enabled=false,amount=50,bias=0,type="float",base=0,range=100,curve="Linear",tooltip="Add random Lowpass/Highpass filtering.\nUses 'JS: Liteon/Moog'."},{key="chaos_echo",label="Delay/Echo",tab="Chaos",enabled=false,amount=30,bias=0,type="float",base=0,range=100,curve="Linear",tooltip="Add random feedback delay lines.\nUses 'ReaDelay'."},{key="chaos_mod",label="Modulation",tab="Chaos",enabled=false,amount=40,bias=0,type="float",base=0,range=100,curve="Linear",tooltip="Add random RingMod/Tremolo movement.\nUses 'JS: Tremolo'."}} local lIlIllII={"Linear","Bell Curve","Exponential"} local lIlIlIlI={} for i,p in ipairs(lIIllII) do lIlIlIlI[p.key]={enabled=p.enabled,amount=p.amount,bias=p.bias,curve_type=p.curve,index=i} end local lIIlIll={} local lIlIIlII,lIlIIIll,lIlIIIlI="","","" function lIlllII() local file=io.open(lIIlIlI,"w") if file then local content="return {\n" for name,settings in pairs(lIIlIll) do content=content..string.format('  ["%s"] = {\n',name) content=content..string.format('    global_chaos = %d,\n',settings.global_chaos or 100) content=content..string.format('    tape_mode = %s,\n',tostring(settings.tape_mode)) for key,p_config in pairs(settings.params) do content=content..string.format('    ["%s"] = { enabled = %s, amount = %d, bias = %d, curve_type = "%s" },\n',key,tostring(p_config.enabled),p_config.amount,p_config.bias,p_config.curve_type) end content=content.."  },\n" end content=content.."}" file:write(content) file:close() if lIIllIl then reaper.ShowConsoleMsg("Presets saved to "..lIIlIlI.."\n") end end end function lIlIllI() local f=loadfile(lIIlIlI) if f then local loaded=f() if type(loaded)=="table" then for name,data in pairs(loaded) do if data.params then lIIlIll[name]=data else lIIlIll[name]={params=data,global_chaos=100,tape_mode=false} end end end end end function lIIlllII(preset_data) if not preset_data then return end lIlllIl=preset_data.global_chaos or 100 lIlIlll=preset_data.tape_mode or false for key,p_settings in pairs(preset_data.params) do if lIlIlIlI[key] then lIlIlIlI[key].enabled=p_settings.enabled lIlIlIlI[key].amount=p_settings.amount lIlIlIlI[key].bias=p_settings.bias or 0 lIlIlIlI[key].curve_type=p_settings.curve_type or "Linear" end end end function lIIllIlI(take,depth,rate) if depth<=0.01 then return end local env=reaper.GetTakeEnvelopeByName(take,"Pitch") if not env then local item=reaper.GetMediaItemTake_Item(take) local sel_items={} for i=0,reaper.CountSelectedMediaItems(0)-1 do table.insert(sel_items,reaper.GetSelectedMediaItem(0,i)) end reaper.Main_OnCommand(40289,0) reaper.SetMediaItemSelected(item,true) reaper.Main_OnCommand(41612,0) for _,it in ipairs(sel_items) do reaper.SetMediaItemSelected(it,true) end env=reaper.GetTakeEnvelopeByName(take,"Pitch") end if not env then return end reaper.DeleteEnvelopePointRange(env,0,999999) local item=reaper.GetMediaItemTake_Item(take) local len=reaper.GetMediaItemInfo_Value(item,"D_LENGTH") local interval=1.0/math.max(0.1,rate) local time=0 reaper.InsertEnvelopePoint(env,0,0,0,0,false,true) while time<len do time=time+interval+(math.random()*interval*0.2) if time>len then time=len end local val=(math.random()*2-1)*depth reaper.InsertEnvelopePoint(env,time,val,2,0,false,true) end reaper.Envelope_SortPoints(env) end function lIllIIll(item) if not lIlIlIlI.slice_prob.enabled then return {item} end local slice_items={} local item_start=reaper.GetMediaItemInfo_Value(item,"D_POSITION") local item_len=reaper.GetMediaItemInfo_Value(item,"D_LENGTH") local item_end=item_start+item_len local grid_map={0.25,0.125,0.0625,0.03125,0.015625} local grid_idx=math.floor((lIlIlIlI.slice_grid.amount/100)*4+0.5)+1 local beat_len=grid_map[grid_idx] or 0.25 local start_beat=reaper.TimeMap2_timeToQN(0,item_start) local end_beat=reaper.TimeMap2_timeToQN(0,item_end) local current_beat=math.ceil(start_beat/beat_len)*beat_len local split_points={} while current_beat<end_beat do local split_time=reaper.TimeMap2_QNToTime(0,current_beat) if split_time>item_start+0.001 and split_time<item_end-0.001 then if math.random()*100<lIlIlIlI.slice_prob.amount then table.insert(split_points,split_time) end end current_beat=current_beat+beat_len end table.sort(split_points,function(a,b) return a>b end) local current_item=item local collected_right_sides={} for _,point in ipairs(split_points) do local new_item=reaper.SplitMediaItem(current_item,point) if new_item then table.insert(collected_right_sides,1,new_item) end end local final_list={current_item} for _,it in ipairs(collected_right_sides) do table.insert(final_list,it) end return final_list end function lIlIlIll(take,vals) local function SetFXParam(fx_name,param_idx,val) local fx_idx=reaper.TakeFX_AddByName(take,fx_name,1) if fx_idx>=0 then reaper.TakeFX_SetParam(take,fx_idx,param_idx,val) reaper.TakeFX_SetEnabled(take,fx_idx,true) return fx_idx end return -1 end local function EnsureBypass(fx_name) local fx_idx=reaper.TakeFX_AddByName(take,fx_name,0) if fx_idx>=0 then reaper.TakeFX_SetEnabled(take,fx_idx,false) end end if lIlIlIlI.chaos_dist.enabled then SetFXParam("JS: Saturation",0,vals.chaos_dist) else EnsureBypass("JS: Saturation") end if lIlIlIlI.chaos_filt.enabled then local cutoff=200+(vals.chaos_filt/100*4000) local idx=SetFXParam("JS: Liteon/moog24db",0,cutoff) if idx==-1 then idx=SetFXParam("JS: 4-Pole Lowpass Filter",0,cutoff) end else EnsureBypass("JS: Liteon/moog24db") EnsureBypass("JS: 4-Pole Lowpass Filter") end if lIlIlIlI.chaos_echo.enabled then local delay_time=(vals.chaos_echo/100)*500 local idx=SetFXParam("JS: Delay",0,delay_time) if idx>=0 then SetFXParam("JS: Delay",1,-6) end else EnsureBypass("JS: Delay") end if lIlIlIlI.chaos_mod.enabled then local freq=1+(vals.chaos_mod/100)*10 local idx=SetFXParam("JS: Tremolo",0,freq) if idx>=0 then SetFXParam("JS: Tremolo",1,-12) end else EnsureBypass("JS: Tremolo") end end function lIIlIIll(track) if not track then return end local fx_name_search="Event Horizon" local existing_idx=-1 local count=reaper.TrackFX_GetCount(track) for i=0,count-1 do local retval,buf=reaper.TrackFX_GetFXName(track,i,"") if retval and buf:lower():find(fx_name_search:lower()) then existing_idx=i break end end local fx_idx=existing_idx if fx_idx<0 then fx_idx=reaper.TrackFX_AddByName(track,"JS: Event Horizon Limiter/Clipper",false,1) if fx_idx<0 then fx_idx=reaper.TrackFX_AddByName(track,"JS: Event Horizon",false,1) end end if fx_idx>=0 then reaper.TrackFX_SetParam(track,fx_idx,1,-0.1) reaper.TrackFX_SetEnabled(track,fx_idx,true) local new_cnt=reaper.TrackFX_GetCount(track) if fx_idx<new_cnt-1 then reaper.TrackFX_CopyToTrack(track,fx_idx,track,new_cnt,true) end end end function lIllIlII(take,density,depth) if density<1 then return end reaper.DeleteTakeStretchMarkers(take,0,reaper.GetTakeNumStretchMarkers(take)) local source=reaper.GetMediaItemTake_Source(take) local source_len=reaper.GetMediaSourceLength(source) local num_markers=math.floor(density) local interval=source_len/(num_markers+1) for i=1,num_markers do local src_pos=i*interval local idx=reaper.SetTakeStretchMarker(take,-1,src_pos) if idx>=0 then local retval,pos,src_pos_out=reaper.GetTakeStretchMarker(take,idx) local jitter=(math.random()-0.5)*2*depth local new_pos=pos+jitter if new_pos<0 then new_pos=0 end reaper.SetTakeStretchMarker(take,idx,new_pos) end end end function lIlIIlll() for _,p in ipairs(lIIllII) do lIlIlIlI[p.key].amount=math.random(0,100) end end function lIIlIlIl() for _,p in ipairs(lIIllII) do lIlIlIlI[p.key].enabled=p.enabled lIlIlIlI[p.key].amount=p.amount lIlIlIlI[p.key].bias=p.bias lIlIlIlI[p.key].curve_type=p.curve end lIlllIl=100 lIlIlll=false end function lIlIIlIl(item,center_pos) local vals={} local chaos_factor=lIlllIl/100.0 for _,p in ipairs(lIIllII) do local user_amount=lIlIlIlI[p.key].amount*chaos_factor local max_range=p.range*(user_amount/100) if p.type=="int" then vals[p.key]=lIlIlIll(p.base,p.base+max_range,lIlIlIlI[p.key].curve_type,lIlIlIlI[p.key].bias) else if p.key=="rate" then vals[p.key]=lIlIlIll(1.0-max_range,1.0+max_range,lIlIlIlI[p.key].curve_type,lIlIlIlI[p.key].bias) elseif p.key=="fm_y" or p.key=="fm_h" then vals[p.key]=lIlIlIll(0,max_range,lIlIlIlI[p.key].curve_type,lIlIlIlI[p.key].bias) else vals[p.key]=lIlIlIll(-max_range,max_range,lIlIlIlI[p.key].curve_type,lIlIlIlI[p.key].bias) end end end local take=reaper.GetActiveTake(item) if not take then return end if lIlIlIlI.rate.enabled then local new_rate=vals.rate if new_rate<0.1 then new_rate=0.1 end reaper.SetMediaItemTakeInfo_Value(take,"D_PLAYRATE",new_rate) if lIlIlll then reaper.SetMediaItemTakeInfo_Value(take,"B_PPITCH",0) local random_pitch=(lIlIlIlI.pitch.enabled and vals.pitch) or 0 reaper.SetMediaItemTakeInfo_Value(take,"D_PITCH",random_pitch) else reaper.SetMediaItemTakeInfo_Value(take,"B_PPITCH",1) if lIlIlIlI.pitch.enabled then reaper.SetMediaItemTakeInfo_Value(take,"D_PITCH",vals.pitch) end end local source=reaper.GetMediaItemTake_Source(take) if source then local source_len=reaper.GetMediaSourceLength(source) if source_len>0 then reaper.SetMediaItemInfo_Value(item,"D_LENGTH",source_len/new_rate) end end elseif lIlIlIlI.pitch.enabled then reaper.SetMediaItemTakeInfo_Value(take,"D_PITCH",vals.pitch) end if lIlIlIlI.reverse.enabled then local chance=lIlIlIlI.reverse.amount*chaos_factor local is_rev=(math.random()*100)<chance if is_rev then local cur_rev=reaper.GetMediaItemTakeInfo_Value(take,"B_REVERSE") reaper.SetMediaItemTakeInfo_Value(take,"B_REVERSE",1-cur_rev) end end if lIlIlIlI.pos.enabled then reaper.SetMediaItemInfo_Value(item,"D_POSITION",center_pos+vals.pos/2) end if lIlIlIlI.drift_depth.enabled then lIIllIlI(take,vals.drift_depth,vals.drift_rate) end if lIlIlIlI.formant.enabled then local fx_idx=reaper.TakeFX_AddByName(take,"VST: ReaPitch (Cockos)",1) if fx_idx<0 then fx_idx=reaper.TakeFX_AddByName(take,"ReaPitch",1) end if fx_idx>=0 then local formant_param_idx=-1 for i=0,20 do local retval,buf=reaper.TakeFX_GetParamName(take,fx_idx,i,"") if retval and (buf:lower():find("formant") or buf:lower():find("shift (formant)")) then formant_param_idx=i break end end if formant_param_idx==-1 then formant_param_idx=4 end if formant_param_idx>=0 then reaper.TakeFX_SetParam(take,fx_idx,formant_param_idx,vals.formant) reaper.TakeFX_SetEnabled(take,fx_idx,true) end end end lIlIlIll(take,vals) if lIlIlIlI.warp_dens.enabled then lIllIlII(take,vals.warp_dens,vals.warp_depth) end if lIlIlIlI.start_offs.enabled then local cur_offs=reaper.GetMediaItemTakeInfo_Value(take,"D_STARTOFFS") local new_offs=cur_offs+vals.start_offs if new_offs<0 then new_offs=0 end reaper.SetMediaItemTakeInfo_Value(take,"D_STARTOFFS",new_offs) end if lIlIlIlI.fm_y.enabled then reaper.SetMediaItemInfo_Value(item,"F_FREEMODE_Y",vals.fm_y) end if lIlIlIlI.fm_h.enabled then local h=math.max(0.1,vals.fm_h) reaper.SetMediaItemInfo_Value(item,"F_FREEMODE_H",h) end if lIlIlIlI.vol.enabled then local volume_multiplier=10^(vals.vol/20) reaper.SetMediaItemInfo_Value(item,"D_VOL",volume_multiplier) end if lIlIlIlI.pan.enabled then reaper.SetMediaItemInfo_Value(item,"D_PAN",vals.pan) end if lIlIlIlI.fade_in.enabled then reaper.SetMediaItemInfo_Value(item,"D_FADEINLEN",vals.fade_in) end if lIlIlIlI.fade_out.enabled then reaper.SetMediaItemInfo_Value(item,"D_FADEOUTLEN",vals.fade_out) end if lIlIlIlI.shape_in.enabled then reaper.SetMediaItemInfo_Value(item,"C_FADEINSHAPE",vals.shape_in) end if lIlIlIlI.shape_out.enabled then reaper.SetMediaItemInfo_Value(item,"C_FADEOUTSHAPE",vals.shape_out) end end function lIIllIll() local selected_items_count=reaper.CountSelectedMediaItems(0) if selected_items_count==0 then reaper.MB("No items selected.","User Error",0) return end reaper.Undo_BeginBlock() reaper.PreventUIRefresh(1) math.randomseed(os.time()) local initial_items={} for i=0,selected_items_count-1 do table.insert(initial_items,reaper.GetSelectedMediaItem(0,i)) end local items_to_process={} for _,item in ipairs(initial_items) do local slices=lIllIIll(item) for _,slice in ipairs(slices) do table.insert(items_to_process,slice) end end local tracks_processed={} for _,item in ipairs(items_to_process) do local track=reaper.GetMediaItem_Track(item) if not tracks_processed[track] then if lIlIlIlI.fm_y.enabled or lIlIlIlI.fm_h.enabled then reaper.SetMediaTrackInfo_Value(track,'I_FREEMODE',1) end tracks_processed[track]=true end if item then lIlIIlIl(item,lIlIIlI) end end reaper.Main_OnCommand(40289,0) local tracks_processed_limiter_check_final={} for _,item in ipairs(items_to_process) do if reaper.ValidatePtr(item,"MediaItem*") then reaper.SetMediaItemSelected(item,true) end if lIIlllI then local tr=reaper.GetMediaItem_Track(item) if not tracks_processed_limiter_check_final[tr] then lIIlIIll(tr) tracks_processed_limiter_check_final[tr]=true end end end reaper.PreventUIRefresh(-1) reaper.UpdateArrange() reaper.Undo_EndBlock("Hosi Variator: Mutate",-1) end function lIllIlll(p) lIlIlIl.TableNextRow(lIllIlI) lIlIlIl.TableNextColumn(lIllIlI) local rv,new_chk=lIlIlIl.Checkbox(lIllIlI,p.label,lIlIlIlI[p.key].enabled) if rv then lIlIlIlI[p.key].enabled=new_chk end if p.tooltip then lIIlIIlI(p.tooltip) end lIlIlIl.TableNextColumn(lIllIlI) lIlIlIl.PushItemWidth(lIllIlI,-1) local slider_id="##amt_"..p.key local ra,new_amt=lIlIlIl.SliderInt(lIllIlI,slider_id,lIlIlIlI[p.key].amount,0,100) if ra then lIlIlIlI[p.key].amount=new_amt end if lIlIlIl.IsItemClicked(lIllIlI,1) then lIlIlIlI[p.key].amount=50 end lIlIlIl.PopItemWidth(lIllIlI) lIlIlIl.TableNextColumn(lIllIlI) lIlIlIl.PushItemWidth(lIllIlI,-1) local rb,new_bias=lIlIlIl.SliderInt(lIllIlI,"##bias_"..p.key,lIlIlIlI[p.key].bias,-100,100) if rb then lIlIlIlI[p.key].bias=new_bias end if lIlIlIl.IsItemClicked(lIllIlI,1) then lIlIlIlI[p.key].bias=0 end lIlIlIl.PopItemWidth(lIllIlI) lIlIlIl.TableNextColumn(lIllIlI) lIlIlIl.PushItemWidth(lIllIlI,-1) local cur_idx=0 for i,c in ipairs(lIlIllII) do if c==lIlIlIlI[p.key].curve_type then cur_idx=i-1 break end end local rc,new_idx=lIlIlIl.Combo(lIllIlI,"##crv_"..p.key,cur_idx,table.concat(lIlIllII,"\0").."\0") if rc then lIlIlIlI[p.key].curve_type=lIlIllII[new_idx+1] end lIlIlIl.PopItemWidth(lIllIlI) lIlIlIl.TableNextColumn(lIllIlI) if lIlIlIl.Button(lIllIlI,"R##"..p.key) then lIlIlIlI[p.key].amount=math.random(0,100) end lIIlIIlI("Randomize this parameter's Intensity (0-100%).") end function lIIlIIlI(text) if lIlIlIl.IsItemHovered(lIllIlI) then lIlIlIl.SetTooltip(lIllIlI,text) end end function lIlIIlllII(tab_name) if lIlIlIl.BeginTable(lIllIlI,"MainLayout_"..tab_name,5,lIlIlIl.TableFlags_BordersInnerV) then lIlIlIl.TableSetupColumn(lIllIlI,"Param",lIlIlIl.TableColumnFlags_WidthFixed,140) lIlIlIl.TableSetupColumn(lIllIlI,"Intensity",lIlIlIl.TableColumnFlags_WidthStretch) lIlIlIl.TableSetupColumn(lIllIlI,"Bias",lIlIlIl.TableColumnFlags_WidthStretch) lIlIlIl.TableSetupColumn(lIllIlI,"Curve",lIlIlIl.TableColumnFlags_WidthFixed,100) lIlIlIl.TableSetupColumn(lIllIlI,"?",lIlIlIl.TableColumnFlags_WidthFixed,25) lIlIlIl.TableHeadersRow(lIllIlI) for _,p in ipairs(lIIllII) do if p.tab==tab_name then lIllIlll(p) end end lIlIlIl.EndTable(lIllIlI) end end function lIlllIll() if lIlIlIl.BeginTable(lIllIlI,"HeaderTable",3) then lIlIlIl.TableSetupColumn(lIllIlI,"Main",lIlIlIl.TableColumnFlags_WidthStretch) lIlIlIl.TableSetupColumn(lIllIlI,"Donate",lIlIlIl.TableColumnFlags_WidthFixed,60) lIlIlIl.TableSetupColumn(lIllIlI,"Help",lIlIlIl.TableColumnFlags_WidthFixed,50) lIlIlIl.TableNextRow(lIllIlI) lIlIlIl.TableNextColumn(lIllIlI) if lIlIlIl.Button(lIllIlI,"Randomize All Settings",-1,24) then lIlIIlll() end if lIlIlIl.IsItemClicked(lIllIlI,1) then lIIlIlIl() end lIIlIIlI("Left Click: Randomize All Sliders\nRight Click: Reset All to Default") lIlIlIl.TableNextColumn(lIllIlI) if lIlIlIl.Button(lIllIlI,"Donate",-1,24) then reaper.CF_ShellExecute('https://paypal.me/nkstudio') end lIIlIIlI("Support the developer!") lIlIlIl.TableNextColumn(lIllIlI) if lIlIlIl.Button(lIllIlI,"Guide",-1,24) then reaper.CF_ShellExecute('https://www.lachinhan.xyz/2025/08/var.html') end lIIlIIlI("Open Online User Guide") lIlIlIl.EndTable(lIllIlI) end lIlIlIl.Separator(lIllIlI) local footer_height=40 if lIlIlIl.BeginChild(lIllIlI,"MainContent",0,-footer_height) then if lIlIlIl.BeginTabBar(lIllIlI,"MyTabBar") then if lIlIlIl.BeginTabItem(lIllIlI,"CORE") then lIlIlIl.Spacing(lIllIlI) local rv,st=lIlIlIl.Checkbox(lIllIlI,"TAPE MODE (Link Rate & Pitch)",lIlIlll) if rv then lIlIlll=st end lIlIlIl.SameLine(lIllIlI) lIlIlIl.TextDisabled(lIllIlI,"(?) Simulates Tape Varispeed") lIlIlIl.Separator(lIllIlI) lIlIIlllII("Core") lIlIlIl.EndTabItem(lIllIlI) end if lIlIlIl.BeginTabItem(lIllIlI,"SPACE & LAYER") then lIlIlIl.Spacing(lIllIlI) lIlIlIl.TextDisabled(lIllIlI,"Control stereo image and layering phase.") lIlIlIl.Separator(lIllIlI) lIlIIlllII("Space") lIlIlIl.EndTabItem(lIllIlI) end if lIlIlIl.BeginTabItem(lIllIlI,"TEXTURE") then lIlIlIl.Spacing(lIllIlI) lIlIlIl.TextDisabled(lIllIlI,"Glance, Reverse, and Envelopes.") lIlIlIl.Separator(lIllIlI) lIlIIlllII("Texture") lIlIlIl.EndTabItem(lIllIlI) end if lIlIlIl.BeginTabItem(lIllIlI,"GLITCH") then lIlIlIl.Spacing(lIllIlI) lIlIlIl.TextDisabled(lIllIlI,"Granular Slicer & Time Warp.") lIlIlIl.Separator(lIllIlI) lIlIIlllII("Glitch") lIlIlIl.Dummy(lIllIlI,0,5) lIlIlIl.TextColored(lIllIlI,0xAAAAAAFF,"Grid Reference:") if lIlIlIl.BeginTable(lIllIlI,"GridRefTable",3) then lIlIlIl.TableSetupColumn(lIllIlI,"C1",lIlIlIl.TableColumnFlags_WidthStretch) lIlIlIl.TableSetupColumn(lIllIlI,"C2",lIlIlIl.TableColumnFlags_WidthStretch) lIlIlIl.TableSetupColumn(lIllIlI,"C3",lIlIlIl.TableColumnFlags_WidthStretch) lIlIlIl.TableNextRow(lIllIlI) lIlIlIl.TableSetColumnIndex(lIllIlI,0) lIlIlIl.BulletText(lIllIlI,"0 = 1/4") lIlIlIl.TableSetColumnIndex(lIllIlI,1) lIlIlIl.BulletText(lIllIlI,"25 = 1/8") lIlIlIl.TableSetColumnIndex(lIllIlI,2) lIlIlIl.BulletText(lIllIlI,"50 = 1/16") lIlIlIl.TableNextRow(lIllIlI) lIlIlIl.TableSetColumnIndex(lIllIlI,0) lIlIlIl.BulletText(lIllIlI,"75 = 1/32") lIlIlIl.TableSetColumnIndex(lIllIlI,1) lIlIlIl.BulletText(lIllIlI,"100= 1/64") lIlIlIl.EndTable(lIllIlI) end lIlIlIl.EndTabItem(lIllIlI) end if lIlIlIl.BeginTabItem(lIllIlI,"CHAOS") then lIlIlIl.Spacing(lIllIlI) lIlIlIl.TextDisabled(lIllIlI,"Randomize FX Chain.") lIlIlIl.Separator(lIllIlI) lIlIIlllII("Chaos") lIlIlIl.Dummy(lIllIlI,0,10) lIlIlIl.TextColored(lIllIlI,0xFFCC00FF,"Warning:") lIlIlIl.TextWrapped(lIllIlI,"Enabling these will ADD plugins to your items if they don't exist.") lIlIlIl.Dummy(lIllIlI,0,10) lIlIlIl.Separator(lIllIlI) local sl_v,sl_chk=lIlIlIl.Checkbox(lIllIlI,"Safety Limiter (Auto-Add Limiter)",lIIlllI) if sl_v then lIIlllI=sl_chk end lIIlIIlI("Automatically adds 'JS: Event Horizon' to preventing clipping/spikes.\nHighly recommended when using CHAOS/Texture effects.") lIlIlIl.EndTabItem(lIllIlI) end if lIlIlIl.BeginTabItem(lIllIlI,"PRESETS") then lIlIlIl.Spacing(lIllIlI) if lIlIlIl.Button(lIllIlI,"Save State",-1) then lIlIlIl.OpenPopup(lIllIlI,"SavePresetPopup") end lIIlIIlI("Save current sliders and checkboxes as a new preset.") lIlIlIl.Separator(lIllIlI) if lIlIlIl.BeginChild(lIllIlI,"PresetList",0,-35,1) then for name,_ in pairs(lIIlIll) do if lIlIlIl.Selectable(lIllIlI,name,lIlIIIlI==name) then lIlIIIlI=name end end lIlIlIl.EndChild(lIllIlI) end if lIlIlIl.Button(lIllIlI,"Load",100) then if lIIlIll[lIlIIIlI] then lIIlllII(lIIlIll[lIlIIIlI]) end end lIlIlIl.SameLine(lIllIlI) if lIlIlIl.Button(lIllIlI,"Delete",80) then lIIlIll[lIlIIIlI]=nil lIlllII() end lIlIlIl.SameLine(lIllIlI) if lIlIlIl.Button(lIllIlI,"Reset Params",90) then lIIlIlIl() end lIIlIIlI("Reset all parameters to default.") if lIlIlIl.BeginPopup(lIllIlI,"SavePresetPopup") then lIlIlIl.Text("Preset Name:") local enter=false local rv,name=lIlIlIl.InputText(lIllIlI,"##psetname",lIlIIlII,256,lIlIlIl.InputTextFlags_EnterReturnsTrue) if rv then lIlIIlII=name enter=true end if lIlIlIl.Button(lIllIlI,"Save") or enter then if lIlIIlII~="" then lIIlIll[lIlIIlII]={global_chaos=lIlllIl,tape_mode=lIlIlll,params=lIlIllll()} lIlllII() lIlIlIl.CloseCurrentPopup(lIllIlI) lIlIIlII="" end end lIlIlIl.SameLine(lIllIlI) if lIlIlIl.Button(lIllIlI,"Cancel") then lIlIlIl.CloseCurrentPopup(lIllIlI) end lIlIlIl.EndPopup(lIllIlI) end lIlIlIl.EndTabItem(lIllIlI) end lIlIlIl.EndTabBar(lIllIlI) end end lIlIlIl.EndChild(lIllIlI) lIlIlIl.Separator(lIllIlI) lIlIlIl.Text(lIllIlI,"GLOBAL CHAOS:") lIlIlIl.SameLine(lIllIlI) lIlIlIl.PushItemWidth(lIllIlI,-120) local rv,gc=lIlIlIl.SliderInt(lIllIlI,"##global_chaos",lIlllIl,0,100,"%d%%") if rv then lIlllIl=gc end lIIlIIlI("Master Scale (0-100%): Reduces the intensity of ALL randomization settings simultaneously.") lIlIlIl.PopItemWidth(lIllIlI) lIlIlIl.SameLine(lIllIlI) if lIlIlIl.Button(lIllIlI,"MUTATE",-1,30) then lIIllIll() end lIIlIIlI("Apply randomization to selected items.") end function lIlIllll() local c={} for key,p_config in pairs(lIlIlIlI) do c[key]={enabled=p_config.enabled,amount=p_config.amount,bias=p_config.bias,curve_type=p_config.curve_type} end return c end function lIlIllllI() local popped_c,popped_v=lIIlIII(lIllIlI) lIlIlIl.SetNextWindowSize(lIllIlI,500,450,lIlIlIl.Cond_FirstUseEver) local visible,open=lIlIlIl.Begin(lIllIlI,'Hosi Variator PRO',true) if visible then lIlllIll() lIlIlIl.End(lIllIlI) end lIlIlIl.PopStyleColor(lIllIlI,popped_c) lIlIlIl.PopStyleVar(lIllIlI,popped_v) if not lIlIlIl.IsAnyItemActive(lIllIlI) then if lIlIlIl.IsKeyPressed(lIllIlI,lIlIlIl.Key_Space,false) then reaper.SetEditCurPos(lIlIIlI,true,true) reaper.Main_OnCommand(40073,0) end end if open then reaper.defer(lIlIllllI) end end lIlIllI() reaper.defer(lIlIllllI)