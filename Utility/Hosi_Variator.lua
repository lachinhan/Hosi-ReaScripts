--[[
@description Hosi Variator - Randomize properties for selected media items
@author      Hosi
@version     1.0
@about
  This script randomizes multiple properties for each selected media item.
  A modern ReaImGui interface with checkboxes and sliders allows for precise control over the randomization process.
  This version has been enhanced with a Preset Management system.
  See more at https://www.lachinhan.xyz/2025/08/var.html

  Instructions:
  1. Select one or more media items on a track.
  2. Place the edit cursor at the center point for horizontal scattering.
  3. Run this script. The ReaImGui window will appear.
  4. Use the checkboxes and sliders to configure randomization settings.
  5. Click "Save Preset" to save the current settings.
  6. Click "Manage Presets" to load, rename, or delete existing presets.
  7. Click "Mutate" to apply the changes.
--]]
package.path = reaper.ImGui_GetBuiltinPath() .. '/?.lua' local ImGui = require('imgui')('0.10') if not ImGui or type(ImGui) ~= "table" then reaper.MB("Failed to initialize ReaImGui library. Please ensure it is installed and up to date via ReaPack.", "Error", 0) return end local ctx = ImGui.CreateContext('Hosi Variator') local ENABLE_CONSOLE_OUTPUT = true local initial_cursor_pos = reaper.GetCursorPosition() local presets_file = reaper.GetResourcePath() .. '/Hosi_Variator_Presets.lua' function random_range(min, max) if min > max then min, max = max, min end return math.random() * (max - min) + min end function random_int_range(min, max) if min > max then min, max = max, min end return math.floor(random_range(min, max + 1 - 1e-9)) end function get_biased_random_linear(min, max, bias) local range = max - min local value = min + math.random() * range if bias ~= 0 then local biased_factor = (bias / 100) * range / 2 value = value + biased_factor end return math.min(max, math.max(min, value)) end function get_biased_random_bell_curve(min, max, bias) local u1, u2 = math.random(), math.random() local z = math.sqrt(-2 * math.log(u1)) * math.cos(2 * math.pi * u2) local mean = (min + max) / 2 local std_dev = (max - min) / 6 local value = z * std_dev + mean if bias ~= 0 then local biased_factor = (bias / 100) * std_dev value = value + biased_factor end return math.min(max, math.max(min, value)) end function get_biased_random_exponential(min, max, bias) local value = min - (max - min) * math.log(1 - math.random()) if bias ~= 0 then local range = max - min local biased_factor = (bias / 100) * range / 2 value = value + biased_factor end return math.min(max, math.max(min, value)) end function get_random_value(min, max, curve_type, bias) if curve_type == "Bell Curve" then return get_biased_random_bell_curve(min, max, bias) elseif curve_type == "Exponential" then return get_biased_random_exponential(min, max, bias) else return get_biased_random_linear(min, max, bias) end end local PARAMETERS = { { key = "pos", label = "Position", enabled = true, amount = 50, bias = 0, type = "float", base = 0, range = 2.0, curve = "Linear" }, { key = "vol", label = "Volume", enabled = true, amount = 50, bias = 0, type = "float", base = 0, range = 12.0, curve = "Linear" }, { key = "pan", label = "Pan", enabled = true, amount = 100, bias = 0, type = "float", base = 0, range = 1.0, curve = "Linear" }, { key = "pitch", label = "Pitch", enabled = true, amount = 20, bias = 0, type = "float", base = 0, range = 12.0, curve = "Linear" }, { key = "rate", label = "Rate", enabled = true, amount = 20, bias = 0, type = "float", base = 1.0, range = 0.5, curve = "Linear" }, { key = "fade_in", label = "Fade In Len", enabled = false, amount = 50, bias = 0, type = "float", base = 0, range = 0.1, curve = "Linear" }, { key = "fade_out", label = "Fade Out Len", enabled = false, amount = 50, bias = 0, type = "float", base = 0, range = 0.1, curve = "Linear" }, { key = "shape_in", label = "Fade In Shape", enabled = false, amount = 100, bias = 0, type = "int", base = 0, range = 6, curve = "Linear" }, { key = "shape_out",label = "Fade Out Shape",enabled = false, amount = 100, bias = 0, type = "int", base = 0, range = 6, curve = "Linear" } } local CURVE_TYPES = { "Linear", "Bell Curve", "Exponential" } local LINK_TYPES = { "None" } local config = {} for i, p in ipairs(PARAMETERS) do config[p.key] = { enabled = p.enabled, amount = p.amount, bias = p.bias, curve_type = p.curve, link_to = p.link, index = i } end local presets = {} local preset_name_buffer = "" local preset_filter_text = "" local selected_preset_name = "" local rename_buffer = "" local open_save_preset_popup = false local open_manage_presets_popup = false function save_presets() local file = io.open(presets_file, "w") if file then local content = "return {\n" for name, settings in pairs(presets) do content = content .. string.format('  ["%s"] = {\n', name) for key, p_config in pairs(settings) do content = content .. string.format('    ["%s"] = { enabled = %s, amount = %d, bias = %d, curve_type = "%s" },\n', key, tostring(p_config.enabled), p_config.amount, p_config.bias, p_config.curve_type) end content = content .. "  },\n" end content = content .. "}" file:write(content) file:close() if ENABLE_CONSOLE_OUTPUT then reaper.ShowConsoleMsg("Presets saved to " .. presets_file .. "\n") end end end function load_presets() local loaded_presets = nil local f, err = loadfile(presets_file) if f then loaded_presets = f() end if type(loaded_presets) == "table" then presets = loaded_presets else if ENABLE_CONSOLE_OUTPUT then reaper.ShowConsoleMsg("No presets file found or file is empty. Starting with no presets.\n") end end end function get_current_config() local current_config = {} for key, p_config in pairs(config) do current_config[key] = { enabled = p_config.enabled, amount = p_config.amount, bias = p_config.bias, curve_type = p_config.curve_type, } end return current_config end function apply_preset(preset_settings) if not preset_settings then return end for key, p_settings in pairs(preset_settings) do if config[key] then config[key].enabled = p_settings.enabled config[key].amount = p_settings.amount config[key].bias = p_settings.bias or 0 config[key].curve_type = p_settings.curve_type or "Linear" end end end function RandomizeAllAmounts() for _, p in ipairs(PARAMETERS) do config[p.key].amount = math.random(0, 100) end end function ResetAllParameters() for _, p in ipairs(PARAMETERS) do config[p.key].enabled = p.enabled config[p.key].amount = p.amount config[p.key].bias = p.bias config[p.key].curve_type = p.curve end end function RandomizeItem(item, center_pos) local randomized_values = {} for _, p in ipairs(PARAMETERS) do local max_range = p.range * (config[p.key].amount / 100) if p.type == "int" then randomized_values[p.key] = get_random_value(p.base, p.base + max_range, config[p.key].curve_type, config[p.key].bias) else randomized_values[p.key] = get_random_value(-max_range, max_range, config[p.key].curve_type, config[p.key].bias) end end if config.pos.enabled then reaper.SetMediaItemInfo_Value(item, "D_POSITION", center_pos + randomized_values.pos / 2) end reaper.SetMediaItemInfo_Value(item, "F_FREEMODE_Y", get_random_value(0, 0.75, "Linear", 0)) reaper.SetMediaItemInfo_Value(item, "F_FREEMODE_H", get_random_value(0.2, 0.4, "Linear", 0)) if config.vol.enabled then local volume_multiplier = 10 ^ (randomized_values.vol / 20) reaper.SetMediaItemInfo_Value(item, "D_VOL", volume_multiplier) end if config.pan.enabled then reaper.SetMediaItemInfo_Value(item, "D_PAN", randomized_values.pan) end if config.fade_in.enabled then reaper.SetMediaItemInfo_Value(item, "D_FADEINLEN", randomized_values.fade_in) end if config.fade_out.enabled then reaper.SetMediaItemInfo_Value(item, "D_FADEOUTLEN", randomized_values.fade_out) end if config.shape_in.enabled then reaper.SetMediaItemInfo_Value(item, "C_FADEINSHAPE", randomized_values.shape_in) end if config.shape_out.enabled then reaper.SetMediaItemInfo_Value(item, "C_FADEOUTSHAPE", randomized_values.shape_out) end local take = reaper.GetActiveTake(item) if take then if config.pitch.enabled then reaper.SetMediaItemTakeInfo_Value(take, "D_PITCH", randomized_values.pitch) end local random_rate = 1.0 if config.rate.enabled then random_rate = randomized_values.rate reaper.SetMediaItemTakeInfo_Value(take, "D_PLAYRATE", random_rate) end local source = reaper.GetMediaItemTake_Source(take) if source then local source_len = reaper.GetMediaSourceLength(source) if source_len > 0 and random_rate > 0 then local new_item_len = source_len / random_rate reaper.SetMediaItemInfo_Value(item, "D_LENGTH", new_item_len) end end end end function RunProcessing() local selected_items_count = reaper.CountSelectedMediaItems(0) if selected_items_count == 0 then reaper.MB("No items selected. Please select one or more media items.", "Action Error", 0) return end reaper.Undo_BeginBlock() local first_item = reaper.GetSelectedMediaItem(0, 0) local track = reaper.GetMediaItem_Track(first_item) reaper.SetMediaTrackInfo_Value(track, 'I_FREEMODE', 1) math.randomseed(os.time()) for i = 0, selected_items_count - 1 do local item = reaper.GetSelectedMediaItem(0, i) if item then RandomizeItem(item, initial_cursor_pos) end end reaper.UpdateArrange() reaper.Undo_EndBlock("Hosi Variator: Mutate", -1) end function DrawGUI() if ImGui.BeginTable(ctx, "TopButtons", 3, ImGui.TableFlags_BordersInnerV) then ImGui.TableSetupColumn(ctx, "Randomize", ImGui.TableColumnFlags_WidthStretch) ImGui.TableSetupColumn(ctx, "Reset", ImGui.TableColumnFlags_WidthStretch) ImGui.TableSetupColumn(ctx, "Donate", ImGui.TableColumnFlags_WidthStretch) ImGui.TableNextRow(ctx) ImGui.TableNextColumn(ctx) if ImGui.Button(ctx, "Randomize", -1, 25) then RandomizeAllAmounts() end ImGui.TableNextColumn(ctx) if ImGui.Button(ctx, "Reset", -1, 25) then ResetAllParameters() end ImGui.TableNextColumn(ctx) if ImGui.Button(ctx, "Donate", -1, 25) then reaper.CF_ShellExecute('https://paypal.me/nkstudio') end ImGui.EndTable(ctx) end ImGui.Separator(ctx) if ImGui.BeginTable(ctx, "PresetButtons", 3, ImGui.TableFlags_BordersInnerV) then ImGui.TableSetupColumn(ctx, "", ImGui.TableColumnFlags_WidthStretch) ImGui.TableSetupColumn(ctx, "", ImGui.TableColumnFlags_WidthStretch) ImGui.TableSetupColumn(ctx, "", ImGui.TableColumnFlags_WidthStretch) ImGui.TableNextRow(ctx) ImGui.TableNextColumn(ctx) if ImGui.Button(ctx, "Save Preset", -1, 25) then open_save_preset_popup = true end ImGui.TableNextColumn(ctx) if ImGui.Button(ctx, "Manage Presets", -1, 25) then open_manage_presets_popup = true end ImGui.TableNextColumn(ctx) if ImGui.Button(ctx, "User Guide", -1, 25) then reaper.CF_ShellExecute('https://www.lachinhan.xyz/2025/08/var.html') end ImGui.EndTable(ctx) end ImGui.Separator(ctx) if ImGui.BeginTable(ctx, "MainLayout", 5, ImGui.TableFlags_BordersInnerV) then ImGui.TableSetupColumn(ctx, "Parameters", ImGui.TableColumnFlags_WidthFixed, 150) ImGui.TableSetupColumn(ctx, "Amount", ImGui.TableColumnFlags_WidthFixed, 100) ImGui.TableSetupColumn(ctx, "Bias", ImGui.TableColumnFlags_WidthFixed, 100) ImGui.TableSetupColumn(ctx, "Curve", ImGui.TableColumnFlags_WidthFixed, 100) ImGui.TableSetupColumn(ctx, "Rand", ImGui.TableColumnFlags_WidthFixed, 30) for _, p in ipairs(PARAMETERS) do ImGui.TableNextRow(ctx) ImGui.TableNextColumn(ctx) local changed, new_val = ImGui.Checkbox(ctx, p.label, config[p.key].enabled) if changed then config[p.key].enabled = new_val end ImGui.TableNextColumn(ctx) ImGui.PushItemWidth(ctx, -1) local slider_changed, slider_new_val = ImGui.SliderInt(ctx, "##" .. p.key, config[p.key].amount, 0, 100) if slider_changed then config[p.key].amount = slider_new_val end if ImGui.IsItemClicked(ctx, 1) then config[p.key].amount = 0 end ImGui.PopItemWidth(ctx) ImGui.TableNextColumn(ctx) ImGui.PushItemWidth(ctx, -1) local bias_changed, bias_new_val = ImGui.SliderInt(ctx, "##bias" .. p.key, config[p.key].bias, -100, 100) if bias_changed then config[p.key].bias = bias_new_val end if ImGui.IsItemClicked(ctx, 1) then config[p.key].bias = 0 end ImGui.PopItemWidth(ctx) ImGui.TableNextColumn(ctx) ImGui.PushItemWidth(ctx, -1) local current_curve_idx = 0 for i, curve_name in ipairs(CURVE_TYPES) do if curve_name == config[p.key].curve_type then current_curve_idx = i - 1 break end end local curve_changed, new_curve_idx = ImGui.Combo(ctx, "##curve" .. p.key, current_curve_idx, table.concat(CURVE_TYPES, "\0") .. "\0") if curve_changed then config[p.key].curve_type = CURVE_TYPES[new_curve_idx + 1] end ImGui.PopItemWidth(ctx) ImGui.TableNextColumn(ctx) if ImGui.SmallButton(ctx, "R##" .. p.key) then config[p.key].amount = math.random(0, 100) end end ImGui.EndTable(ctx) end ImGui.Separator(ctx) if ImGui.Button(ctx, "Mutate", -1, 40) then RunProcessing() end end function DrawPopups() if open_save_preset_popup then ImGui.OpenPopup(ctx, "Save Preset") open_save_preset_popup = false end if ImGui.BeginPopupModal(ctx, "Save Preset", nil, ImGui.WindowFlags_AlwaysAutoResize) then ImGui.Text(ctx, "Enter preset name:") local name_changed, new_name = ImGui.InputText(ctx, "##preset_name", preset_name_buffer, 256) if name_changed then preset_name_buffer = new_name end if ImGui.Button(ctx, "Save") then if preset_name_buffer and preset_name_buffer:match("%S") then presets[preset_name_buffer] = get_current_config() save_presets() if ENABLE_CONSOLE_OUTPUT then reaper.ShowConsoleMsg("Preset saved: " .. preset_name_buffer .. "\n") end preset_name_buffer = "" ImGui.CloseCurrentPopup(ctx) end end ImGui.SameLine(ctx) if ImGui.Button(ctx, "Cancel") then preset_name_buffer = "" ImGui.CloseCurrentPopup(ctx) end ImGui.EndPopup(ctx) end if open_manage_presets_popup then ImGui.OpenPopup(ctx, "Manage Presets") open_manage_presets_popup = false end if ImGui.BeginPopupModal(ctx, "Manage Presets", nil, ImGui.WindowFlags_AlwaysAutoResize) then ImGui.Text(ctx, "Filter:") ImGui.SameLine(ctx) local filter_changed, new_filter = ImGui.InputText(ctx, "##filter", preset_filter_text, 256) if filter_changed then preset_filter_text = new_filter end ImGui.Separator(ctx) local preset_names = {} for name in pairs(presets) do if name:lower():find(preset_filter_text:lower(), 1, true) then table.insert(preset_names, name) end end table.sort(preset_names) ImGui.BeginChild(ctx, "##presetlistbox", -1, 200, 1, 0) for _, name in ipairs(preset_names) do local is_selected = (selected_preset_name == name) if ImGui.Selectable(ctx, name, is_selected) then selected_preset_name = name end end ImGui.EndChild(ctx) ImGui.Separator(ctx) ImGui.BeginGroup(ctx) if ImGui.Button(ctx, "Load") and selected_preset_name ~= "" then apply_preset(presets[selected_preset_name]) ImGui.CloseCurrentPopup(ctx) end ImGui.SameLine(ctx) if ImGui.Button(ctx, "Rename") and selected_preset_name ~= "" then rename_buffer = selected_preset_name ImGui.OpenPopup(ctx, "Rename Preset") end ImGui.SameLine(ctx) if ImGui.Button(ctx, "Delete") and selected_preset_name ~= "" then presets[selected_preset_name] = nil save_presets() selected_preset_name = "" end ImGui.SameLine(ctx) if ImGui.Button(ctx, "Close") then ImGui.CloseCurrentPopup(ctx) end ImGui.EndGroup(ctx) if ImGui.BeginPopupModal(ctx, "Rename Preset", nil, ImGui.WindowFlags_AlwaysAutoResize) then ImGui.Text(ctx, "Enter new name:") local rename_changed, new_rename = ImGui.InputText(ctx, "##renamebuffer", rename_buffer, 256) if rename_changed then rename_buffer = new_rename end if ImGui.Button(ctx, "OK") then if rename_buffer and rename_buffer:match("%S") then presets[rename_buffer] = presets[selected_preset_name] presets[selected_preset_name] = nil save_presets() selected_preset_name = rename_buffer end ImGui.CloseCurrentPopup(ctx) end ImGui.SameLine(ctx) if ImGui.Button(ctx, "Cancel") then ImGui.CloseCurrentPopup(ctx) end ImGui.EndPopup(ctx) end ImGui.EndPopup(ctx) end end function loop() ImGui.SetNextWindowSize(ctx, 400, 410, ImGui.Cond_FirstUseEver) local visible, open = ImGui.Begin(ctx, 'Hosi Variator', true) if visible then DrawGUI() DrawPopups() ImGui.End(ctx) end if not reaper.ImGui_IsAnyItemActive(ctx) then if reaper.ImGui_IsKeyPressed(ctx, reaper.ImGui_Key_Space(), false) then reaper.SetEditCurPos(initial_cursor_pos, true, true) reaper.Main_OnCommand(40073, 0) end end if open then reaper.defer(loop) end end load_presets() reaper.defer(loop)
