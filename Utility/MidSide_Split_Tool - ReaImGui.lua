--[[
@description Hosi Mid/Side Split Tool
@author      Hosi Prod
@version     1.0
@about
  [A tool for REAPER that splits stereo audio tracks into separate Mid and Side components. 
  It automatically creates a new track folder with the original, Mid, and Side tracks, which are then routed to the master track. 
  The script also includes options to preserve item colors, add a spectrum analyzer, or apply an EQ optimization for vocals.
  Instructions: Select one or more stereo audio tracks and run the script. The script will handle the rest.]
--]]
package.path = reaper.ImGui_GetBuiltinPath() .. '/?.lua' local ImGui = require 'imgui' '0.9.3' local ctx = ImGui.CreateContext('Mid/Side Split Tool') local CONFIG = { folder_suffix = " MS", orig_prefix = "ORIG ", mid_prefix = "MID ", side_prefix = "SIDE ", colors = { mid = {255, 200, 100}, side = {100, 200, 255}, orig = {180, 180, 180}, folder = {220, 220, 220} }, preserve_item_colors = true, auto_solo_ms_tracks = false, create_send_to_master = true, add_spectrum_analyzer = false, vocal_mode = false } function ValidateSelection() local sel_tracks = reaper.CountSelectedTracks(0) if sel_tracks == 0 then return nil, "Please select at least one track." end local tracks = {} for i = 0, sel_tracks - 1 do tracks[#tracks + 1] = reaper.GetSelectedTrack(0, i) end return tracks, nil end function GetAudioItems(track) local items = {} local mono_items = {} local item_count = reaper.CountTrackMediaItems(track) for i = 0, item_count - 1 do local item = reaper.GetTrackMediaItem(track, i) local take = reaper.GetActiveTake(item) if take and not reaper.TakeIsMIDI(take) then local source = reaper.GetMediaItemTake_Source(take) local source_type = reaper.GetMediaSourceType(source, "") if source_type == "WAVE" or source_type == "FLAC" or source_type == "MP3" or source_type == "AIFF" then local num_channels = reaper.GetMediaSourceNumChannels(source) if num_channels >= 2 then items[#items + 1] = item else local item_name = reaper.GetTakeName(take) if item_name == "" then item_name = "Unnamed Item " .. (i + 1) end mono_items[#mono_items + 1] = item_name end end end end return items, mono_items end function CreateTrackStructure(track, track_name, track_idx) reaper.InsertTrackAtIndex(track_idx, true) local folder_track = reaper.GetTrack(0, track_idx) reaper.GetSetMediaTrackInfo_String(folder_track, "P_NAME", track_name .. CONFIG.folder_suffix, true) reaper.SetMediaTrackInfo_Value(folder_track, "I_FOLDERDEPTH", 1) local folder_color = reaper.ColorToNative( CONFIG.colors.folder[1], CONFIG.colors.folder[2], CONFIG.colors.folder[3] ) | 0x1000000 reaper.SetTrackColor(folder_track, folder_color) local orig_track = reaper.GetTrack(0, track_idx + 1) reaper.GetSetMediaTrackInfo_String(orig_track, "P_NAME", CONFIG.orig_prefix .. track_name, true) reaper.InsertTrackAtIndex(track_idx + 2, true) local mid_track = reaper.GetTrack(0, track_idx + 2) reaper.GetSetMediaTrackInfo_String(mid_track, "P_NAME", CONFIG.mid_prefix .. track_name, true) reaper.InsertTrackAtIndex(track_idx + 3, true) local side_track = reaper.GetTrack(0, track_idx + 3) reaper.GetSetMediaTrackInfo_String(side_track, "P_NAME", CONFIG.side_prefix .. track_name, true) reaper.SetMediaTrackInfo_Value(orig_track, "I_FOLDERDEPTH", 0) reaper.SetMediaTrackInfo_Value(mid_track, "I_FOLDERDEPTH", 0) reaper.SetMediaTrackInfo_Value(side_track, "I_FOLDERDEPTH", -1) reaper.SetMediaTrackInfo_Value(orig_track, "B_MUTE", 1) local folder_fx = reaper.TrackFX_AddByName(folder_track, "JS: Mid/Side Decoder", false, -1) if folder_fx >= 0 then reaper.TrackFX_SetOpen(folder_track, folder_fx, false) end if CONFIG.add_spectrum_analyzer then local analyzer_fx = reaper.TrackFX_AddByName(folder_track, "ReaEQ", false, -1) if analyzer_fx >= 0 then reaper.TrackFX_SetOpen(folder_track, analyzer_fx, false) end end local mid_color = reaper.ColorToNative(CONFIG.colors.mid[1], CONFIG.colors.mid[2], CONFIG.colors.mid[3]) | 0x1000000 local side_color = reaper.ColorToNative(CONFIG.colors.side[1], CONFIG.colors.side[2], CONFIG.colors.side[3]) | 0x1000000 local orig_color = reaper.ColorToNative(CONFIG.colors.orig[1], CONFIG.colors.orig[2], CONFIG.colors.orig[3]) | 0x1000000 reaper.SetTrackColor(mid_track, mid_color) reaper.SetTrackColor(side_track, side_color) reaper.SetTrackColor(orig_track, orig_color) if CONFIG.auto_solo_ms_tracks then reaper.SetMediaTrackInfo_Value(mid_track, "I_SOLO", 1) reaper.SetMediaTrackInfo_Value(side_track, "I_SOLO", 1) end if CONFIG.create_send_to_master then local master_track = reaper.GetMasterTrack(0) reaper.CreateTrackSend(mid_track, master_track) reaper.CreateTrackSend(side_track, master_track) end return folder_track, orig_track, mid_track, side_track end function ProcessItemEnhanced(item, orig_track, mid_track, side_track, temp_track) local item_pos = reaper.GetMediaItemInfo_Value(item, "D_POSITION") local item_len = reaper.GetMediaItemInfo_Value(item, "D_LENGTH") local item_vol = reaper.GetMediaItemInfo_Value(item, "D_VOL") local item_color = reaper.GetMediaItemInfo_Value(item, "I_CUSTOMCOLOR") local take = reaper.GetActiveTake(item) if not take then return false end local source = reaper.GetMediaItemTake_Source(take) local orig_name = reaper.GetTakeName(take) if orig_name == "" then orig_name = "Item" end local temp_item_count = reaper.CountTrackMediaItems(temp_track) for i = temp_item_count - 1, 0, -1 do local temp_item = reaper.GetTrackMediaItem(temp_track, i) reaper.DeleteTrackMediaItem(temp_track, temp_item) end reaper.SetOnlyTrackSelected(temp_track) reaper.SetMediaItemSelected(item, true) reaper.Main_OnCommand(40698, 0) reaper.Main_OnCommand(40058, 0) if reaper.CountTrackMediaItems(temp_track) == 0 then return false end local temp_item = reaper.GetTrackMediaItem(temp_track, 0) local temp_take = reaper.GetActiveTake(temp_item) if not temp_take then return false end local fx_idx = reaper.TakeFX_AddByName(temp_take, "JS: Mid/Side Encoder", 1) if fx_idx >= 0 then reaper.TakeFX_SetEnabled(temp_take, fx_idx, true) end if CONFIG.vocal_mode then local mid_eq = reaper.TrackFX_AddByName(mid_track, "ReaEQ", false, -1) if mid_eq >= 0 then reaper.TrackFX_SetParam(mid_track, mid_eq, 4, 0.25) reaper.TrackFX_SetParam(mid_track, mid_eq, 5, 0.124) reaper.TrackFX_SetParam(mid_track, mid_eq, 6, 0.6) reaper.TrackFX_SetParam(mid_track, mid_eq, 7, 0.4) reaper.TrackFX_SetParam(mid_track, mid_eq, 8, 0.5) end local side_eq = reaper.TrackFX_AddByName(side_track, "ReaEQ", false, -1) if side_eq >= 0 then reaper.TrackFX_SetParam(side_track, side_eq, 8, 1.0) reaper.TrackFX_SetParam(side_track, side_eq, 9, 0.75) reaper.TrackFX_SetParam(side_track, side_eq, 10, 0.45) end end reaper.SetOnlyTrackSelected(temp_track) reaper.SetMediaItemSelected(temp_item, true) reaper.Main_OnCommand(40362, 0) local glued_item = reaper.GetTrackMediaItem(temp_track, 0) if not glued_item then return false end local glued_take = reaper.GetActiveTake(glued_item) if not glued_take then return false end local glued_source = reaper.GetMediaItemTake_Source(glued_take) local mid_item = reaper.AddMediaItemToTrack(mid_track) reaper.SetMediaItemInfo_Value(mid_item, "D_POSITION", item_pos) reaper.SetMediaItemInfo_Value(mid_item, "D_LENGTH", item_len) reaper.SetMediaItemInfo_Value(mid_item, "D_VOL", item_vol) local mid_take = reaper.AddTakeToMediaItem(mid_item) reaper.SetMediaItemTake_Source(mid_take, glued_source) reaper.GetSetMediaItemTakeInfo_String(mid_take, "P_NAME", CONFIG.mid_prefix .. orig_name, true) reaper.SetMediaItemTakeInfo_Value(mid_take, "I_CHANMODE", 3) local mid_item_color = CONFIG.preserve_item_colors and item_color ~= 0 and item_color or (reaper.ColorToNative(CONFIG.colors.mid[1], CONFIG.colors.mid[2], CONFIG.colors.mid[3]) | 0x1000000) reaper.SetMediaItemInfo_Value(mid_item, "I_CUSTOMCOLOR", mid_item_color) local side_item = reaper.AddMediaItemToTrack(side_track) reaper.SetMediaItemInfo_Value(side_item, "D_POSITION", item_pos) reaper.SetMediaItemInfo_Value(side_item, "D_LENGTH", item_len) reaper.SetMediaItemInfo_Value(side_item, "D_VOL", item_vol) local side_take = reaper.AddTakeToMediaItem(side_item) reaper.SetMediaItemTake_Source(side_take, glued_source) reaper.GetSetMediaItemTakeInfo_String(side_take, "P_NAME", CONFIG.side_prefix .. orig_name, true) reaper.SetMediaItemTakeInfo_Value(side_take, "I_CHANMODE", 4) local side_item_color = CONFIG.preserve_item_colors and item_color ~= 0 and item_color or (reaper.ColorToNative(CONFIG.colors.side[1], CONFIG.colors.side[2], CONFIG.colors.side[3]) | 0x1000000) reaper.SetMediaItemInfo_Value(side_item, "I_CUSTOMCOLOR", side_item_color) reaper.SetMediaTrackInfo_Value(mid_track, "D_PAN", -0.95) reaper.SetMediaTrackInfo_Value(side_track, "D_PAN", 0.95) return true end function ProcessTrack(track, temp_track) local track_name = "" local _, track_name = reaper.GetTrackName(track) if track_name == "" then track_name = "Track" end local track_idx = reaper.GetMediaTrackInfo_Value(track, "IP_TRACKNUMBER") - 1 local items, mono_items = GetAudioItems(track) if #mono_items > 0 then return false, "Track contains mono items,\n" .. "or formats other than WAVE, FLAC, MP3 and AIFF" end if #items == 0 then return false, "Track has no stereo audio items,\n" .. "or formats other than WAVE, FLAC, MP3 and AIFF" end local folder_track, orig_track, mid_track, side_track = CreateTrackStructure(track, track_name, track_idx) local processed_count = 0 for i = 1, #items do if ProcessItemEnhanced(items[i], orig_track, mid_track, side_track, temp_track) then processed_count = processed_count + 1 end end return processed_count > 0, nil end local function DrawSimpleGUI() ImGui.Text(ctx, "Mid/Side Split Tool") ImGui.Separator(ctx) ImGui.SetNextItemWidth(ctx, 120) local folder_changed, folder_new = ImGui.InputText(ctx, "Folder Suffix", CONFIG.folder_suffix) if folder_changed then CONFIG.folder_suffix = folder_new end ImGui.Separator(ctx) local preserve_changed, preserve_new = ImGui.Checkbox(ctx, "Preserve item colors", CONFIG.preserve_item_colors) if preserve_changed then CONFIG.preserve_item_colors = preserve_new end local solo_changed, solo_new = ImGui.Checkbox(ctx, "Auto solo Mid/Side tracks", CONFIG.auto_solo_ms_tracks) if solo_changed then CONFIG.auto_solo_ms_tracks = solo_new end local send_changed, send_new = ImGui.Checkbox(ctx, "Create send to Master", CONFIG.create_send_to_master) if send_changed then CONFIG.create_send_to_master = send_new end local analyzer_changed, analyzer_new = ImGui.Checkbox(ctx, "Add Spectrum Analyzer", CONFIG.add_spectrum_analyzer) if analyzer_changed then CONFIG.add_spectrum_analyzer = analyzer_new end local vocal_changed, vocal_new = ImGui.Checkbox(ctx, "Vocal mode (EQ optimization)", CONFIG.vocal_mode) if vocal_changed then CONFIG.vocal_mode = vocal_new end ImGui.Separator(ctx) if ImGui.Button(ctx, "Process Mid/Side Split", -1, 40) then local tracks, error_msg = ValidateSelection() if not tracks then reaper.ShowMessageBox(error_msg, "Error", 0) return end if reaper.CountSelectedMediaItems(0) > 0 then reaper.ShowMessageBox("Please unselect all media items before running.\nThis script operates on selected tracks only.", "Warning", 0) return end reaper.Undo_BeginBlock() reaper.PreventUIRefresh(1) reaper.InsertTrackAtIndex(reaper.GetNumTracks(), true) local temp_track = reaper.GetTrack(0, reaper.GetNumTracks() - 1) reaper.GetSetMediaTrackInfo_String(temp_track, "P_NAME", "temp_ms_processing", true) local success_count = 0 local total_tracks = #tracks local error_details = {} for i = 1, total_tracks do local success, error = ProcessTrack(tracks[i], temp_track) if success then success_count = success_count + 1 else local _, track_name = reaper.GetTrackName(tracks[i]) if track_name == "" then track_name = "Track " .. i end table.insert(error_details, track_name .. ": " .. (error or "Unknown error")) end end reaper.DeleteTrack(temp_track) reaper.PreventUIRefresh(-1) reaper.UpdateArrange() reaper.Undo_EndBlock("Mid/Side Split", -1) reaper.Main_OnCommand(40042, 0) local message = "" if success_count > 0 then message = string.format("Successfully processed %d/%d tracks.", success_count, total_tracks) if #error_details > 0 then message = message .. "\n\nErrors:\n" .. table.concat(error_details, "\n") end else message = "No tracks were processed successfully.\n\n" .. table.concat(error_details, "\n") end reaper.ShowMessageBox(message, "Processing Complete", 0) end end local function loop() ImGui.SetNextWindowSize(ctx, 350, 280, ImGui.Cond_FirstUseEver) local visible, open = ImGui.Begin(ctx, 'Mid/Side Split Tool', true) if visible then DrawSimpleGUI() ImGui.End(ctx) end if open then reaper.defer(loop) end end reaper.defer(loop)
