--[[
@description Hosi Tempo Detect Item (GUI Version)
@author      Hosi Prod (Algorithm by MPL)
@version     2.0
@provides
  [main] . > Hosi_Detect item tempo (GUI).lua

@about
  Select an audio item, detect its tempo, then choose from suggested BPM values to apply.
  See more at https://www.lachinhan.xyz/2025/07/tempo.html

  Features:
  - Includes genre presets for quick tempo suggestions.
  - Uses Reaper's native snap action "Item: Snap items to nearest snap point" (ID 41184) for reliable item snapping.
  - The "Snap item" option is disabled when "Create Detailed Tempo Map" mode is active.
  - A preset system to save and recall your settings.
--]]
package.path = reaper.ImGui_GetBuiltinPath() .. '/?.lua' local ImGui = require 'imgui' '0.9.3' if not ImGui then reaper.ShowMessageBox("ReaImGui library is required for this script.\nPlease install it via ReaPack -> Extensions -> ReaImGui.", "Error", 0) return end local ctx = ImGui.CreateContext('Tempo Detect Tool') local PRESETS = { { name = "01. General - Safe Default (80-160)", min = 80, max = 160 }, { name = "02. General - Wide Range (70-180)", min = 70, max = 180 }, { name = "03. Mainstream - Ballad / R&B / Lo-fi (60-90)", min = 60, max = 90 }, { name = "04. Mainstream - Hip Hop (80-115)", min = 80, max = 115 }, { name = "05. Mainstream - Pop (90-130)", min = 90, max = 130 }, { name = "06. Mainstream - Rock (110-140)", min = 110, max = 140 }, { name = "07. Mainstream - Jazz (Standard) (80-140)", min = 80, max = 140 }, { name = "08. House - General / Disco (115-135)", min = 115, max = 135 }, { name = "09. House - Deep House (120-130)", min = 120, max = 130 }, { name = "10. House - Progressive House (125-135)", min = 125, max = 135 }, { name = "11. House - Electro / Funky (128-138)", min = 128, max = 138 }, { name = "12. House - Tribal / Latin (128-140)", min = 128, max = 140 }, { name = "13. Techno - General (125-145)", min = 125, max = 145 }, { name = "14. Trance - General (130-140)", min = 130, max = 140 }, { name = "15. Trance - Vocal Trance (133-145)", min = 133, max = 145 }, { name = "16. Trance - Uplifting Trance (138-145)", min = 138, max = 145 }, { name = "17. Bass - Dubstep / Trap (135-150, half-time feel)", min = 135, max = 150 }, { name = "18. High Energy - Drum & Bass (160-180)", min = 160, max = 180 }, { name = "19. High Energy - Hardstyle / Hardcore (140-180+)", min = 140, max = 180 } } local preset_names_str = (function() local names = {} for i = 1, #PRESETS do table.insert(names, PRESETS[i].name) end return table.concat(names, '\0') .. '\0' end)() local CONFIG = { preset_idx = 1, min_bpm_range = PRESETS[1].min, max_bpm_range = PRESETS[1].max, tempo_choices = {}, apply_mode = 1, add_stretch_markers = true, snap_to_bar = true } local status_message = "Please select an audio item and click Detect." for key in pairs(reaper) do _G[key]=reaper[key] end DATA2 = { Median_weightptscnt = 8, TimeOut = 5, tol_inner = 0.025, testing_beats = 8, LP_ratio = 0.2, FFT_size = 256, min_bpm = 90, max_bpm = 180, tolpre = 0.1, tolpost = 0.1, } function CopyTable(orig) local orig_type = type(orig) local copy if orig_type == 'table' then copy = {} for orig_key, orig_value in next, orig, nil do copy[CopyTable(orig_key)] = CopyTable(orig_value) end setmetatable(copy, CopyTable(getmetatable(orig))) else copy = orig end return copy end function DATA2:GetFunctionMedianPeaks(t) local sz = #t local L, m, a, w = 0.6, DATA2.Median_weightptscnt, 0.2, 0.2 local largest_peak, N, median, thresh_t = 0, 0, 0, {} for i = 1, sz do local val = t[i] largest_peak = math.max(largest_peak, val) N = w * largest_peak median = 0 local mean, meancnt = 0, 0 local med_t = {} for j = i - m, i do if t[j] then med_t[#med_t + 1] = t[j] meancnt = meancnt + 1 mean = mean + t[j] end end if meancnt > 0 then mean = mean / meancnt end table.sort(med_t) if #med_t >= 3 then median = med_t[math.floor(#med_t / 2)] end thresh_t[i] = L * median + a * mean + N end return thresh_t end function DATA2:GetComplexDomainOnsetEnvelope_GetDifference(buft) local out_t = {[1]=0, [2]=0} for frame = 3, #buft do local t, t_prev, t_prev2 = buft[frame], buft[frame - 1], buft[frame - 2] local sz, sum = #t, 0 local hp, lp = 2, sz - math.floor(sz * DATA2.LP_ratio) for bin = hp, lp do local magnitude_targ = t_prev[bin].magnitude local phase_targ = t_prev[bin].phase + (t_prev[bin].phase - t_prev2[bin].phase) local Re2 = magnitude_targ * math.cos(phase_targ) local Im2 = magnitude_targ * math.sin(phase_targ) local Re1 = t[bin].magnitude * math.cos(t[bin].phase) local Im1 = t[bin].magnitude * math.sin(t[bin].phase) local Euclidean_distance = math.sqrt((Re2 - Re1) ^ 2 + (Im2 - Im1) ^ 2) sum = sum + Euclidean_distance * (1 - bin / sz) end out_t[frame] = (sum ^ 3) * buft[frame].rms end return out_t end function DATA2:GetComplexDomainOnsetEnvelope(item) DATA2.item_ptr, DATA2.item_pos, DATA2.item_len = item, GetMediaItemInfo_Value(item, 'D_POSITION'), GetMediaItemInfo_Value(item, 'D_LENGTH') local take = GetActiveTake(item) if not take or TakeIsMIDI(take) then return end local pcm_src = GetMediaItemTake_Source(take) DATA2.SR = GetMediaSourceSampleRate(pcm_src) local FFTsz, window_spls = DATA2.FFT_size, DATA2.FFT_size * 2 local window = window_spls / DATA2.SR local samplebuffer = reaper.new_array(window_spls) local accessor = CreateTakeAudioAccessor(take) DATA2.CDOE_window = window local buft, buftid = {}, 0 for pos_seek = 0, DATA2.item_len, window do GetAudioAccessorSamples(accessor, DATA2.SR, 1, pos_seek, window_spls, samplebuffer) samplebuffer.fft_real(FFTsz, true, 1) local rms, rmscnt, bin2 = 0, 0, -1 buftid = buftid + 1 buft[buftid] = {} for bin = 1, FFTsz / 2 do bin2 = bin2 + 2 local Re, Im = samplebuffer[bin2], samplebuffer[bin2 + 1] local magnitude = math.sqrt(Re ^ 2 + Im ^ 2) rms = rms + magnitude rmscnt = rmscnt + 1 buft[buftid][bin] = { magnitude = magnitude, phase = math.atan(Im, Re) } end buft[buftid].rms = rms / rmscnt end local t = DATA2:GetComplexDomainOnsetEnvelope_GetDifference(buft) samplebuffer.clear() DestroyAudioAccessor(accessor) return t end function DATA2:GetClusters(t, evt_src) local ClusterWidth, testing_beats, clusters = 0.01, DATA2.testing_beats, {} for eventid = evt_src, evt_src + testing_beats do for j = evt_src, evt_src + testing_beats do if eventid ~= j and t[eventid] and t[j] then local IOI = math.abs(t[j].pos - t[eventid].pos) if IOI > 0 then local k for clustid = 1, #clusters do local RMSinterval = 0 for m = 1, #clusters[clustid].IOIs do RMSinterval = RMSinterval + clusters[clustid].IOIs[m] end RMSinterval = RMSinterval / #clusters[clustid].IOIs clusters[clustid].interval = RMSinterval if math.abs(clusters[clustid].interval - IOI) < ClusterWidth then clusters[clustid].IOIs[#clusters[clustid].IOIs + 1] = IOI k = true end end if not k then clusters[#clusters + 1] = { interval = IOI, IOIs = { IOI } } end end end end end for i = 1, #clusters do local interval, bpm = clusters[i].interval, 60 / clusters[i].interval local min_bpm, max_bpm = DATA2.min_bpm, DATA2.max_bpm while bpm < min_bpm do bpm, interval = bpm * 2, interval / 2 end while bpm > max_bpm do bpm, interval = bpm / 2, interval * 2 end clusters[i] = { interval = interval, bpm = bpm } end return clusters end function DATA2:BuildBeatMap(t_in) local E = {} for i = 1, #t_in do if t_in[i] > 0 then E[#E + 1] = { pos = (i - 1) * DATA2.CDOE_window, val = t_in[i] } end end if #E < 2 then return end local clusters = DATA2:GetClusters(E, 1) DATA2.agents = {} local k = 0 for clust_i = 1, #clusters do for event = 1, math.min(#E, DATA2.testing_beats) do k = k + 1 DATA2.agents[k] = { beatInterval = clusters[clust_i].interval, history = { E[event].pos }, matches = 1 } end end for i = 1, #E do for j = 1, #DATA2.agents do local tolpre = DATA2.tolpre * DATA2.agents[j].beatInterval local tolpost = DATA2.tolpost * DATA2.agents[j].beatInterval local cur_agent_position = DATA2.agents[j].history[#DATA2.agents[j].history] while cur_agent_position + tolpost < E[i].pos do DATA2.agents[j].history[#DATA2.agents[j].history + 1] = cur_agent_position + DATA2.agents[j].beatInterval cur_agent_position = cur_agent_position + DATA2.agents[j].beatInterval end if E[i].pos >= cur_agent_position - tolpre and E[i].pos <= cur_agent_position + tolpost then DATA2.agents[j].matches = DATA2.agents[j].matches + 1 DATA2.agents[j].history[#DATA2.agents[j].history] = E[i].pos end end end local best_match, best_match_id = 0 for i = 1, #DATA2.agents do if DATA2.agents[i].matches > best_match then best_match, best_match_id = DATA2.agents[i].matches, i end end DATA2.best_match_id = best_match_id end function DATA2:GetItemTempoBeats(item) local CDOE = DATA2:GetComplexDomainOnsetEnvelope(item) if not CDOE then return end local threshold_median = DATA2:GetFunctionMedianPeaks(CDOE) local CDOE2 = CopyTable(CDOE) for i = 1, #CDOE2 - DATA2.Median_weightptscnt do if CDOE2[i] < threshold_median[i + 2] then CDOE2[i] = 0 end end CDOE2[#CDOE2 - 1], CDOE2[#CDOE2] = 0, 0 for i = 1, DATA2.Median_weightptscnt * 2 do CDOE2[i] = 0 end local lasttrig for i = 1, #CDOE2 do if CDOE2[i] > 0 and not lasttrig then lasttrig = true elseif lasttrig == true and CDOE2[i] > 0 then CDOE2[i] = 0 elseif CDOE2[i] == 0 then lasttrig = nil end end DATA2:BuildBeatMap(CDOE2) end function DetectTempo() local item = reaper.GetSelectedMediaItem(0, 0) if not item then status_message = "Error: Please select a single media item." return end status_message = "Analyzing, please wait..." CONFIG.tempo_choices = {} reaper.defer(function() end) DATA2.min_bpm = CONFIG.min_bpm_range DATA2.max_bpm = CONFIG.max_bpm_range DATA2:GetItemTempoBeats(item) if not DATA2.best_match_id or not DATA2.agents[DATA2.best_match_id] then status_message = "Error: Could not determine a valid tempo." return end local best_agent = DATA2.agents[DATA2.best_match_id] local beat_interval = best_agent.beatInterval if not beat_interval or beat_interval == 0 then status_message = "Error: Could not determine a valid tempo." return end local detected_tempo = 60 / beat_interval if detected_tempo > (CONFIG.max_bpm_range * 0.95) then table.insert(CONFIG.tempo_choices, detected_tempo) table.insert(CONFIG.tempo_choices, detected_tempo / 2) elseif detected_tempo < (CONFIG.min_bpm_range * 1.05) then table.insert(CONFIG.tempo_choices, detected_tempo) table.insert(CONFIG.tempo_choices, detected_tempo * 2) else table.insert(CONFIG.tempo_choices, detected_tempo) end status_message = "Detection complete. Please choose a tempo to apply." end function ApplyTempo(final_bpm) local item = reaper.GetSelectedMediaItem(0, 0) if not item then status_message = "Error: Item no longer selected." return end reaper.Undo_BeginBlock() reaper.PreventUIRefresh(1) local final_tempo_rounded = math.floor(final_bpm + 0.5) local item_pos = reaper.GetMediaItemInfo_Value(item, "D_POSITION") local original_timebase = reaper.GetMediaItemInfo_Value(item, 'C_BEATATTACHMODE') reaper.SetMediaItemInfo_Value(item, 'C_BEATATTACHMODE', 0) while reaper.CountTempoTimeSigMarkers(0) > 0 do reaper.DeleteTempoTimeSigMarker(0, 0) end if CONFIG.apply_mode == 1 then reaper.SetCurrentBPM(0, final_tempo_rounded, true) elseif CONFIG.apply_mode == 2 then if DATA2.best_match_id and DATA2.agents[DATA2.best_match_id] then local beats = DATA2.agents[DATA2.best_match_id].history if beats and #beats > 1 then for i = 1, #beats - 1 do local pos1 = item_pos + beats[i] local pos2 = item_pos + beats[i+1] local interval = pos2 - pos1 if interval > 0 then local bpm_marker = 60 / interval if final_bpm < (bpm_marker / 1.5) then bpm_marker = bpm_marker / 2 end if final_bpm > (bpm_marker * 1.5) then bpm_marker = bpm_marker * 2 end reaper.SetTempoTimeSigMarker(0, -1, pos1, -1, -1, bpm_marker, 4, 4, true) end end end end end reaper.UpdateArrange() if CONFIG.snap_to_bar then reaper.Main_OnCommand(41184, 0) end reaper.SetMediaItemInfo_Value(item, 'C_BEATATTACHMODE', original_timebase) if CONFIG.add_stretch_markers then local take = reaper.GetActiveTake(item) if take and DATA2.best_match_id and DATA2.agents[DATA2.best_match_id] then local beats = DATA2.agents[DATA2.best_match_id].history if beats then for i = 1, #beats do reaper.SetTakeStretchMarker(take, -1, beats[i]) end end end end status_message = string.format("Success! Applied tempo %d BPM.", final_tempo_rounded) CONFIG.tempo_choices = {} reaper.UpdateArrange() reaper.PreventUIRefresh(-1) reaper.Undo_EndBlock("GUI Tempo Detect and Apply", 1) end function DrawGUI() ImGui.Text(ctx, "Hosi's Tempo Detector (GUI)") ImGui.Separator(ctx) ImGui.TextWrapped(ctx, "Select an audio item, configure options, click 'Detect Tempo', then choose one of the suggested BPMs to apply.") ImGui.Separator(ctx) ImGui.Text(ctx, "Genre Preset") ImGui.SetNextItemWidth(ctx, -1) local preset_changed, new_preset_idx_0based = ImGui.Combo(ctx, "##Preset", CONFIG.preset_idx - 1, preset_names_str) if preset_changed then CONFIG.preset_idx = new_preset_idx_0based + 1 CONFIG.min_bpm_range = PRESETS[CONFIG.preset_idx].min CONFIG.max_bpm_range = PRESETS[CONFIG.preset_idx].max end ImGui.Text(ctx, "Tempo Detection Range") ImGui.SetNextItemWidth(ctx, 120) local min_changed, min_new = ImGui.InputInt(ctx, "Min BPM", CONFIG.min_bpm_range) if min_changed then CONFIG.min_bpm_range = min_new end ImGui.SameLine(ctx) ImGui.SetNextItemWidth(ctx, 120) local max_changed, max_new = ImGui.InputInt(ctx, "Max BPM", CONFIG.max_bpm_range) if max_changed then CONFIG.max_bpm_range = max_new end ImGui.Separator(ctx) ImGui.Text(ctx, "Apply Mode") if ImGui.RadioButton(ctx, "Set Single Project Tempo", CONFIG.apply_mode == 1) then CONFIG.apply_mode = 1 end if ImGui.RadioButton(ctx, "Create Detailed Tempo Map", CONFIG.apply_mode == 2) then CONFIG.apply_mode = 2 end ImGui.Separator(ctx) ImGui.Text(ctx, "Additional Options") local sm_changed, sm_new = ImGui.Checkbox(ctx, "Add Stretch Markers to item", CONFIG.add_stretch_markers) if sm_changed then CONFIG.add_stretch_markers = sm_new end ImGui.BeginDisabled(ctx, CONFIG.apply_mode == 2) local snap_changed, snap_new = ImGui.Checkbox(ctx, "Snap item using Reaper's snap settings", CONFIG.snap_to_bar) if snap_changed and CONFIG.apply_mode ~= 2 then CONFIG.snap_to_bar = snap_new end if CONFIG.apply_mode == 2 then CONFIG.snap_to_bar = false end ImGui.EndDisabled(ctx) ImGui.Separator(ctx) if ImGui.Button(ctx, "Detect Tempo", -1, 40) then DetectTempo() end ImGui.Separator(ctx) if #CONFIG.tempo_choices > 0 then ImGui.Text(ctx, "Confirm and Apply Tempo:") for _, bpm_choice in ipairs(CONFIG.tempo_choices) do if ImGui.Button(ctx, string.format("Apply %.1f BPM", bpm_choice), 120, 25) then ApplyTempo(bpm_choice) end ImGui.SameLine(ctx) end ImGui.NewLine(ctx) ImGui.Separator(ctx) end ImGui.TextWrapped(ctx, "Status: " .. status_message) end function loop() ImGui.SetNextWindowSize(ctx, 420, 480, ImGui.Cond_FirstUseEver) local visible, open = ImGui.Begin(ctx, 'Tempo Detect Tool', true) if visible then DrawGUI() end ImGui.End(ctx) if open then reaper.defer(loop) end end reaper.defer(loop)
