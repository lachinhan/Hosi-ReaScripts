--[[
@description    Import regions from a .txt chord sheet generated by ChordPulse and set project tempo.
@author         Hosi
@version        0.1
@website        https://www.lachinhan.xyz
@provides
  [main] . > Hosi_Import project regions from ChordPulse file.lua

@about
  # Import Project Regions from ChordPulse Sheet

  Reads a .txt chord sheet exported from ChordPulse
  and creates project regions corresponding to the chords and their positions.
  It also reads the tempo from the file (e.g., "Tempo: 140 BPM") and sets it for the project.
  Regions are now color-coded based on chord type (Major, minor, 7th, etc.).

@changelog
  + v0.1 (2025-10-01) - Initial release based on Hosi's script, adapted for ChordPulse format.
--]]

---------------------------------------------------------------------
-- LOGIC FUNCTIONS
---------------------------------------------------------------------

-- Helper function to convert a hex color string (e.g., "#FF9800") to REAPER's native integer format.
function ColorHexToInt(hex)
  hex = hex:gsub("#", "")
  local R = tonumber("0x"..hex:sub(1,2))
  local G = tonumber("0x"..hex:sub(3,4))
  local B = tonumber("0x"..hex:sub(5,6))
  return reaper.ColorToNative(R, G, B)
end

-- Parses the text file content from ChordPulse and extracts chord and tempo information.
function ParseFileContent(file_content)
    local result = {
        chords = {}, -- Table to store the parsed chords
        tempo = nil  -- Variable to store the parsed tempo
    }
    local bar_counter = 1    -- Start counting bars from 1

    local lines = {}
    -- Split the entire file content into individual lines
    for line in file_content:gmatch("([^\r\n]*)") do
        table.insert(lines, line)
    end

    for _, line in ipairs(lines) do
        -- Try to find the tempo on the current line
        local found_tempo = line:match("Tempo:%s*([%d%.]+)")
        if found_tempo and not result.tempo then
            result.tempo = tonumber(found_tempo)
        end

        -- A valid chord line must start with '|' (ignoring leading whitespace)
        if line:match("^%s*|") then
            -- Find all content between '|' characters, which represents a measure
            for measure_content in line:gmatch("|([^|]+)") do
                -- Trim whitespace from the measure content
                local trimmed_content = measure_content:match("^%s*(.-)%s*$")
                
                -- Extract the first sequence of non-space characters, which should be the chord name.
                -- A chord name can contain letters, numbers, '#', 'b', and '/'
                local chord_name = trimmed_content:match("^([%a%d#b/]+)")
                
                -- If a valid chord name was found (i.e., it's not a placeholder dot)
                -- we add it to our list. Empty bars are skipped, letting the previous chord's region extend.
                if chord_name and chord_name ~= "." then
                    table.insert(result.chords, { name = chord_name, bar = bar_counter, beat = 1 })
                end
                
                -- Increment bar counter for each measure processed
                bar_counter = bar_counter + 1
            end
        end
    end
    
    return result
end

-- Creates project regions from the parsed list of chords.
function CreateRegionsFromChords(chords)
    if not chords or #chords == 0 then
        reaper.ShowMessageBox("No valid chords found in the file.", "Import Warning", 0)
        return 0
    end
    
    local proj = 0 -- Current project
    local regions_created = 0 -- Counter for created regions
    
    -- Get the number of beats per measure from the project (defaults to 4)
    local _, num, den = reaper.GetProjectTimeSignature(0)
    if num == 0 then num = 4 end -- Default to 4/4 if not set

    -- Helper function to calculate the absolute beat position
    local function get_abs_beat(chord)
        return (chord.bar - 1) * num + (chord.beat - 1)
    end

    -- Sort chords chronologically to ensure correct region lengths
    table.sort(chords, function(a, b)
        return get_abs_beat(a) < get_abs_beat(b)
    end)
    
    for i = 1, #chords do
        local current_chord = chords[i]
        local next_chord = chords[i + 1]
        
        -- Calculate the start position for the current region (in beats)
        local start_beat_pos = get_abs_beat(current_chord)
        
        -- Calculate the end position for the current region
        local end_beat_pos
        if next_chord then
            -- The region ends where the next chord begins
            end_beat_pos = get_abs_beat(next_chord)
        else
            -- For the very last chord, make the region one measure long
            end_beat_pos = start_beat_pos + num 
        end
        
        -- Convert beat positions to time (seconds)
        local start_time = reaper.TimeMap2_beatsToTime(proj, start_beat_pos)
        local end_time = reaper.TimeMap2_beatsToTime(proj, end_beat_pos)
        
        -- Only create the region if the time is valid
        if start_time and end_time and end_time > start_time then
            -- Determine the color based on the chord name
            local color = 0
            local chord_name = current_chord.name
            
            -- The order of these checks is important to correctly identify complex chords
            if chord_name:match("m7") or chord_name:match("min7") then
              color = ColorHexToInt("#9C27B0") -- Purple for Minor 7th
            elseif chord_name:match("m") then
              color = ColorHexToInt("#F44336") -- Red for Minor
            elseif chord_name:match("7") or chord_name:match("6") then
              color = ColorHexToInt("#FF9800") -- Orange for Dominant/Extended
            else
              -- Default to Major color for anything else
              color = ColorHexToInt("#4CAF50") -- Green for Major
            end
            
            -- Set a REAPER-specific flag to enable the custom color
            color = color | 0x1000000

            -- Add the region to the project with the calculated color
            reaper.AddProjectMarker2(proj, true, start_time, end_time, chord_name, 0, color)
            regions_created = regions_created + 1
        end
    end
    
    reaper.UpdateArrange() -- Update the arrange view GUI
    return regions_created
end


---------------------------------------------------------------------
-- SCRIPT ENTRY POINT
---------------------------------------------------------------------

function main()
    reaper.Undo_BeginBlock() -- Start Undo block for safe execution
    
    -- Open a dialog for the user to select a .txt file
    local retval, file_path = reaper.GetUserFileNameForRead("", "Select ChordPulse .txt file", "txt")
    
    if retval and file_path and file_path ~= "" then
        reaper.PreventUIRefresh(1) -- Defer UI updates to prevent flickering
        
        local file = io.open(file_path, "r")
        if file then
            local content = file:read("*a") -- Read the entire file content
            file:close()
            
            local parsed_data = ParseFileContent(content)
            
            -- Set project tempo if found in file
            if parsed_data.tempo then
                -- Clear any existing tempo markers to ensure a clean slate.
                -- This prevents conflicts with tempo changes already in the project.
                while reaper.CountTempoTimeSigMarkers(0) > 0 do
                    reaper.DeleteTempoTimeSigMarker(0, 0)
                end
                
                -- Set the project's main tempo. This is more direct and robust.
                reaper.SetCurrentBPM(0, parsed_data.tempo, true)
                reaper.UpdateTimeline()
            end
            
            local count = CreateRegionsFromChords(parsed_data.chords)
            
            reaper.PreventUIRefresh(-1) -- Force all deferred UI updates to execute now

            if count > 0 or parsed_data.tempo then
                local message = ""
                if count > 0 then
                    message = message .. count .. " regions were created successfully."
                end
                if parsed_data.tempo then
                    if message ~= "" then message = message .. "\n" end
                    message = message .. "Project tempo set to " .. parsed_data.tempo .. " BPM."
                end
            
                reaper.ShowMessageBox(message, "Import Complete", 0)
                reaper.Undo_EndBlock("Import regions and tempo from ChordPulse .txt", 0) -- Save Undo state
            else
                reaper.ShowMessageBox("Could not create any regions. Please check the file format.", "Import Failed", 0)
                reaper.Undo_EndBlock("Import from .txt (failed)", -1) -- Cancel Undo state
            end
            
        else
            reaper.PreventUIRefresh(-1) -- Still need to re-enable UI updates on error
            reaper.ShowMessageBox("Error: Could not open the selected file.", "File Error", 0)
            reaper.Undo_EndBlock("Import from .txt (file error)", -1)
        end
    else
        -- User cancelled the file dialog
        reaper.Undo_EndBlock("Import from .txt (cancelled)", -1)
    end
end

-- Run the main function
main()

