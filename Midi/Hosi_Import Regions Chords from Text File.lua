--[[
@description    Import regions from a .txt chord sheet generated by Hosi's export script.
@author         Hosi
@version        0.1
@website        https://www.lachinhan.xyz
@provides
  [main] . > Hosi_Import project regions from chord sheet.lua

@about
  # Import Project Regions from Chord Sheet

  Reads a simple .txt chord sheet (in the format created by 'Hosi_Export project regions to chord sheet.lua')
  and creates project regions corresponding to the chords and their positions.

@changelog
   + v0.1 (2025-09-30) - Initial release.
--]]

---------------------------------------------------------------------
-- LOGIC FUNCTIONS
---------------------------------------------------------------------

-- Parses the text file content and extracts chord information
function ParseChordSheet(file_content)
    local parsed_chords = {}
    local lines = {}
    for line in file_content:gmatch("([^\r\n]*)") do
        table.insert(lines, line)
    end

    for _, line in ipairs(lines) do
        -- Find all bars in a line, e.g., "[1] Am | - | G | C"
        for bar_str, content_str in line:gmatch("%[([%d]+)%]%s*([^%[]+)") do
            local bar = tonumber(bar_str)
            if bar then
                local beats = {}
                -- Split content by '|' to get each beat
                for beat_content in content_str:gmatch("([^|]+)") do
                    -- Clean up extra whitespace
                    table.insert(beats, beat_content:match("^%s*(.-)%s*$"))
                end

                for i = 1, #beats do
                    local beat_slot = i
                    local chord_text = beats[i]
                    
                    if chord_text and chord_text ~= "" and chord_text ~= "-" then
                        -- Handle cases with multiple chords in one beat, e.g., "Am/G"
                        for chord_name in chord_text:gmatch("([^/]+)") do
                            table.insert(parsed_chords, { name = chord_name, bar = bar, beat = beat_slot })
                        end
                    end
                end
            end
        end
    end
    return parsed_chords
end

-- Creates project regions from the parsed list of chords
function CreateRegionsFromChords(chords)
    if not chords or #chords == 0 then
        reaper.ShowMessageBox("No valid chords found in the file.", "Import Warning", 0)
        return 0
    end
    
    local proj = 0
    local regions_created = 0
    
    -- Get the number of beats per measure from the project (defaults to 4)
    local _, num, den = reaper.GetProjectTimeSignature(0)
    if num == 0 then num = 4 end

    -- Helper function to calculate the absolute beat position
    local function get_abs_beat(chord)
        return (chord.bar - 1) * num + (chord.beat - 1)
    end

    -- Sort chords chronologically
    table.sort(chords, function(a, b)
        return get_abs_beat(a) < get_abs_beat(b)
    end)
    
    for i = 1, #chords do
        local current_chord = chords[i]
        local next_chord = chords[i + 1]
        
        -- Calculate the start position for the current region
        local start_beat_pos = get_abs_beat(current_chord)
        
        -- Calculate the end position for the current region
        local end_beat_pos
        if next_chord then
            -- The end position is the start position of the next chord
            end_beat_pos = get_abs_beat(next_chord)
        else
            -- For the last chord, make the region one measure long
            end_beat_pos = start_beat_pos + num 
        end
        
        -- Convert beat positions to time (seconds)
        local start_time = reaper.TimeMap2_beatsToTime(proj, start_beat_pos)
        local end_time = reaper.TimeMap2_beatsToTime(proj, end_beat_pos)
        
        -- Only create the region if the time is valid
        if start_time and end_time and end_time > start_time then
            -- Add the region to the project
            reaper.AddProjectMarker2(proj, true, start_time, end_time, current_chord.name, 0, 0)
            regions_created = regions_created + 1
        end
    end
    
    reaper.UpdateArrange() -- Update the arrange view GUI
    return regions_created
end


---------------------------------------------------------------------
-- SCRIPT ENTRY POINT
---------------------------------------------------------------------

function main()
    reaper.Undo_BeginBlock() -- Start Undo block
    
    -- Use a simpler and more reliable file filter
    local retval, file_path = reaper.GetUserFileNameForRead("", "Select Chord Sheet .txt file", "txt")
    
    if retval and file_path and file_path ~= "" then
        local file = io.open(file_path, "r")
        if file then
            local content = file:read("*a") -- Read the entire file content
            file:close()
            
            local chords_to_create = ParseChordSheet(content)
            local count = CreateRegionsFromChords(chords_to_create)
            
            if count > 0 then
                reaper.ShowMessageBox(count .. " regions were created successfully.", "Import Complete", 0)
                reaper.Undo_EndBlock("Import regions from .txt", 0) -- Save Undo state
            else
                reaper.ShowMessageBox("Could not create regions. Please check the file format.", "Import Failed", 0)
                reaper.Undo_EndBlock("Import from .txt (failed)", -1) -- Cancel Undo state
            end
            
        else
            reaper.ShowMessageBox("Error: Could not open the selected file.", "File Error", 0)
            reaper.Undo_EndBlock("Import from .txt (file error)", -1)
        end
    else
        -- User cancelled
        reaper.Undo_EndBlock("Import from .txt (cancelled)", -1)
    end
end

-- Run the main function
main()
