--[[
@description Hosi - ElevenLabs Sound Effects
@version 1.7
@author Hosi
@about
  - A helper script to generate sound effects using the ElevenLabs API.
  - Supports generating audio from the text box or from the notes of multiple selected items.
  - Based on the original Hosi - ElevenLabs TTS script.
@changelog
  + v1.7 (2025-08-17)
    - ADDED: Sequence Generation. Use '|' to separate prompts in the text box.
  + v1.6 (2025-08-14)
    - ADDED: Prompt Presets feature.
  + v1.5 (2025-08-14)
    - ADDED: "Generate as New Takes" feature. Variations are now added as takes to a single item.
  + v1.4 (2025-08-14)
    - ADDED: Advanced Insertion Options.
  + v1.3 (2025-08-13)
    - IMPROVED: Re-implemented item detection using a robust "snapshot" method.
  + v1.2 (2025-08-12)
    - ADDED: "Number of Variations" setting.
  + v1.1 (2025-07-11)
    - FIXED: Text input issues.
  + v1.0 (2025-07-10)
    - Initial release.
@reaper_version 7.0
@depends ReaTeam Extensions/API/reaper_imgui.ext
--]]
reaper.ClearConsole() if not reaper.ImGui_CreateContext then reaper.ShowMessageBox("This script requires the ReaImGui extension.\n\nPlease install it from ReaPack (under the 'Extensions' section) and restart REAPER.", "Error: ReaImGui Not Found", 0) return end local reaper_imgui = reaper.ImGui_CreateContext("ElevenLabs Sound Effects") local settings_file = reaper.GetResourcePath() .. '/hosi_elevenlabs_sfx_settings.txt' local presets_file = reaper.GetResourcePath() .. '/hosi_elevenlabs_sfx_presets.txt' local path_sep = reaper.GetOS():find("Win") and "\\" or "/" local api_keys_string = "" local duration_seconds = "3.5" local prompt_influence = "0.3" local number_of_iterations = "1" local input_text = "A cinematic explosion with debris falling|A car passes by quickly|Distant thunder" local is_processing = false local insertion_mode = 1 local generate_as_takes = true local prompt_presets = {} local selected_preset_idx = 0 local preset_filter_text = "" local listbox_selected_idx = -1 local rename_buffer = "" local preset_to_rename_idx = -1 local open_preset_manager_popup = false function string.split(inputstr, sep) if sep == nil then sep = "%s" end local t={} for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do table.insert(t, str:match("^%s*(.-)%s*$")) end return t end function load_presets() local file = io.open(presets_file, "r") if file then prompt_presets = {} for line in file:lines() do if line:match("%S") then table.insert(prompt_presets, line) end end file:close() end end function save_presets() local file = io.open(presets_file, "w") if file then table.sort(prompt_presets) for _, preset in ipairs(prompt_presets) do file:write(preset .. "\n") end file:close() end end function load_settings() local file = io.open(settings_file, "r") if file then api_keys_string = file:read("*line") or api_keys_string duration_seconds = file:read("*line") or duration_seconds prompt_influence = file:read("*line") or prompt_influence number_of_iterations = file:read("*line") or number_of_iterations insertion_mode = tonumber(file:read("*line")) or insertion_mode local takes_setting = file:read("*line") if takes_setting ~= nil then generate_as_takes = (takes_setting == "true") end file:close() end end function save_settings() local file = io.open(settings_file, "w") if file then file:write(api_keys_string .. "\n") file:write(duration_seconds .. "\n") file:write(prompt_influence .. "\n") file:write(number_of_iterations .. "\n") file:write(tostring(insertion_mode) .. "\n") file:write(tostring(generate_as_takes) .. "\n") file:close() end end function escape_json_text(text) local result = text:gsub('\\', '\\\\'):gsub('"', '\\"'):gsub('\n', '\\n'):gsub('\r', '\\r'):gsub('\t', '\\t'):gsub('[\b\f]', function(c) return string.format("\\%s", c) end):gsub("[%z\1-\31]", function(c) return string.format("\\u%04x", string.byte(c)) end) return result end function generate_unique_filename(text, iteration) local timestamp = os.date("%Y%m%d_%H%M%S") local words = {} for word in text:gmatch("%w+") do table.insert(words, word) if #words >= 3 then break end end local abbreviation = table.concat(words, "_") return "SFX_ElevenLabs_" .. timestamp .. "_" .. abbreviation .. "_v" .. iteration .. ".mp3" end function set_item_note_to_text(item, note) reaper.ULT_SetMediaItemNote(item, note) end function set_item_name_with_suffix(item, base_name) local take = reaper.GetActiveTake(item) if take then local new_name = base_name:gsub("%.mp3$", "") reaper.GetSetMediaItemTakeInfo_String(take, "P_NAME", new_name, true) end end function get_track_from_guid(guid_string) if not guid_string or guid_string == "" then return nil end for i = 0, reaper.CountTracks(0) - 1 do local track = reaper.GetTrack(0, i) if reaper.GetTrackGUID(track) == guid_string then return track end end return nil end function get_all_items_on_track(track) local items_set = {} if not track then return items_set end local num_items = reaper.CountTrackMediaItems(track) for i = 0, num_items - 1 do items_set[reaper.GetTrackMediaItem(track, i)] = true end return items_set end function check_and_process_results(jobs, sentinel_file, log_file, ps_script_file, wait_start_time) if not reaper.file_exists(sentinel_file) then reaper.defer(function() check_and_process_results(jobs, sentinel_file, log_file, ps_script_file, nil) end) return end if not wait_start_time then reaper.ShowConsoleMsg("Generation process finished. Waiting a moment before importing files...\n") reaper.defer(function() check_and_process_results(jobs, sentinel_file, log_file, ps_script_file, reaper.time_precise()) end) return end if reaper.time_precise() - wait_start_time < 0.5 then reaper.defer(function() check_and_process_results(jobs, sentinel_file, log_file, ps_script_file, wait_start_time) end) return end reaper.ShowConsoleMsg("Importing generated files...\n") local result_output = "" local log_handle = io.open(log_file, "r") if log_handle then result_output = log_handle:read("*a") log_handle:close() else result_output = "Error: Could not read temporary log file after process completion." end reaper.ShowConsoleMsg(result_output .. "\n") os.remove(log_file) os.remove(sentinel_file) if reaper.file_exists(ps_script_file) then os.remove(ps_script_file) end reaper.Undo_BeginBlock() local success_count = 0 local next_insert_pos = -1 local main_items = {} for _, job in ipairs(jobs) do if reaper.file_exists(job.outputFile) then local track = get_track_from_guid(job.track_guid_string) if track then reaper.SetOnlyTrackSelected(track) local main_item_for_prompt = main_items[job.prompt_id] if generate_as_takes and main_item_for_prompt then local source = reaper.PCM_Source_CreateFromFile(job.outputFile) if source then local new_take = reaper.AddTakeToMediaItem(main_item_for_prompt) if new_take then reaper.SetMediaItemTake_Source(new_take, source) local take_name = job.filename:gsub("%.mp3$", "") reaper.GetSetMediaItemTakeInfo_String(new_take, "P_NAME", take_name, true) success_count = success_count + 1 end else reaper.ShowConsoleMsg("Warning: Could not create source for take from file: " .. job.outputFile .. "\n") end else local current_insert_pos if job.from_notes and insertion_mode == 2 then current_insert_pos = job.position else if next_insert_pos == -1 then if job.from_notes then next_insert_pos = job.position else next_insert_pos = reaper.GetCursorPosition() end end current_insert_pos = next_insert_pos end reaper.Main_OnCommand(40289, 0) reaper.SetEditCurPos(current_insert_pos, false, false) local items_before = get_all_items_on_track(track) reaper.InsertMedia(job.outputFile, 0) reaper.UpdateArrange() local items_after = get_all_items_on_track(track) local new_item = nil for item_ptr, _ in pairs(items_after) do if not items_before[item_ptr] then new_item = item_ptr break end end if new_item then reaper.SetMediaItemPosition(new_item, current_insert_pos, false) set_item_note_to_text(new_item, job.text) set_item_name_with_suffix(new_item, job.filename) success_count = success_count + 1 if generate_as_takes then main_items[job.prompt_id] = new_item end if not (job.from_notes and insertion_mode == 2) then next_insert_pos = reaper.GetMediaItemInfo_Value(new_item, "D_POSITION") + reaper.GetMediaItemInfo_Value(new_item, "D_LENGTH") end else reaper.ShowConsoleMsg("Warning: Failed to find newly inserted media item using snapshot method for file: " .. job.outputFile .. "\n") end end else reaper.ShowConsoleMsg("Warning: Could not find original track for job (GUID: " .. job.track_guid_string .. "). It may have been deleted.\n") end end end reaper.UpdateArrange() if success_count > 0 then reaper.Undo_EndBlock("Generate & Arrange " .. success_count .. " ElevenLabs SFX", 1) reaper.ShowConsoleMsg("Successfully generated and inserted " .. success_count .. " of " .. #jobs .. " requested sound(s).\n") else reaper.Undo_EndBlock("Generate SFX (Failed)", -1) if not result_output:match("POWERSHELL_ERROR") then reaper.ShowMessageBox("Failed to generate any audio. Check the console for errors.", "Error", 0) end end if success_count < #jobs then reaper.ShowMessageBox("Could not generate all requested sounds. " .. success_count .. " of " .. #jobs .. " were successful. Please check the console log for details.", "Warning", 0) end is_processing = false end function execute_batch_generation(jobs, track) if not jobs or #jobs == 0 then return end if is_processing then reaper.ShowMessageBox("Already processing a request. Please wait.", "Info", 0) return end local keys_to_try = string.split(api_keys_string, ",") local first_api_key = nil for _, key in ipairs(keys_to_try) do local clean_key = key:match("^%s*(.-)%s*$") if clean_key and #clean_key > 10 then first_api_key = clean_key break end end if not first_api_key then reaper.ShowMessageBox("No valid API Keys found. Please add keys in Settings.", "Error", 0) return end local project_path = reaper.GetProjectPath("") if project_path == "" then reaper.ShowMessageBox("Please save the project first.", "Error", 0) return end local track_guid_string = reaper.GetTrackGUID(track) local json_parts = {} for _, job in ipairs(jobs) do job.track_guid_string = track_guid_string local escaped_text = escape_json_text(job.text) local escaped_filepath = job.outputFile:gsub("\\", "\\\\") table.insert(json_parts, string.format('{"text": "%s", "file": "%s"}', escaped_text, escaped_filepath)) end local json_string = '[' .. table.concat(json_parts, ',') .. ']' local temp_log_file = reaper.GetResourcePath() .. path_sep .. "hosi_sfx_temp_log.txt" local sentinel_file = reaper.GetResourcePath() .. path_sep .. "hosi_sfx_finished.tmp" local ps_script_file = reaper.GetResourcePath() .. path_sep .. "hosi_sfx_runner.ps1" if reaper.file_exists(temp_log_file) then os.remove(temp_log_file) end if reaper.file_exists(sentinel_file) then os.remove(sentinel_file) end if reaper.file_exists(ps_script_file) then os.remove(ps_script_file) end local ps_script_content = string.format([[ # This script is auto-generated by Hosi - ElevenLabs Sound Effects try { $ErrorActionPreference = 'Continue'; $jobs = '%s' | ConvertFrom-Json; $apiKey = '%s'; $headers = @{'xi-api-key'=$apiKey; 'accept'='audio/mpeg'; 'Content-Type'='application/json'}; $totalJobs = $jobs.Count; $currentJobIndex = 1; Write-Host ('Starting batch generation of ' + $totalJobs + ' sound(s)...'); foreach ($job in $jobs) { $jobText = $job.text; $jobFile = $job.file; Write-Host (''); Write-Host ('- Generating (' + $currentJobIndex + '/' + $totalJobs + '): ' + $jobText); $body = [PSCustomObject]@{ text = $jobText; duration_seconds = [double]%s; prompt_influence = [double]%s; } | ConvertTo-Json -Compress; try { Invoke-WebRequest -Uri 'https://api.elevenlabs.io/v1/sound-generation' -Method POST -Headers $headers -Body $body -OutFile $jobFile -ErrorAction Stop; Write-Host ('  Success -> ' + $jobFile); } catch { Write-Error ('[POWERSHELL_ERROR] Generation failed for item `"' + $jobText + '`". Reason: ' + $_.Exception.ToString()) } $currentJobIndex++; } Write-Host (''); Write-Host 'Batch process finished.'; } finally { Set-Content -Path '%s' -Value 'done' } ]], json_string, first_api_key, duration_seconds, prompt_influence, sentinel_file:gsub("\\", "\\\\")) local ps_file_handle = io.open(ps_script_file, "w") if not ps_file_handle then reaper.ShowMessageBox("Error: Could not write temporary PowerShell script file.", "Error", 0) is_processing = false return end ps_file_handle:write(ps_script_content) ps_file_handle:close() local ps_command = string.format("powershell -NoProfile -ExecutionPolicy Bypass -File \"%s\" *> \"%s\"", ps_script_file, temp_log_file) is_processing = true reaper.ShowConsoleMsg("Starting batch generation...\nThis may take a moment. A terminal window might briefly appear.\n\n") os.execute("start /B " .. ps_command) reaper.defer(function() check_and_process_results(jobs, sentinel_file, temp_log_file, ps_script_file, nil) end) end function get_destination_track() local dest_track if insertion_mode == 3 then reaper.Undo_BeginBlock() local num_tracks_before = reaper.CountTracks(0) reaper.InsertTrackAtIndex(num_tracks_before, true) dest_track = reaper.GetTrack(0, num_tracks_before) reaper.Undo_EndBlock("Create new track for SFX", 0) else dest_track = reaper.GetSelectedTrack(0, 0) end if not dest_track and reaper.CountTracks(0) > 0 then dest_track = reaper.GetTrack(0, 0) end return dest_track end function generate_from_textbox(is_sequence) local track = get_destination_track() if not track then reaper.ShowMessageBox("No track available. Please select a track or create one.", "Error", 0) return end local project_path = reaper.GetProjectPath("") if project_path == "" then reaper.ShowMessageBox("Please save the project first.", "Error", 0) return end local jobs = {} local prompts = {} if is_sequence then for prompt in input_text:gmatch("([^|]+)") do local trimmed_prompt = prompt:match("^%s*(.-)%s*$") if #trimmed_prompt > 0 then table.insert(prompts, trimmed_prompt) end end if #prompts == 0 then reaper.ShowMessageBox("Sequence input is empty or invalid. Please use '|' to separate prompts.", "Info", 0) return end else table.insert(prompts, input_text) end local iterations = tonumber(number_of_iterations) if not iterations or iterations < 1 then iterations = 1 end for prompt_idx, prompt_text in ipairs(prompts) do local prompt_id = "textbox_prompt_" .. prompt_idx for i = 1, iterations do local unique_filename = generate_unique_filename(prompt_text, i) local output_file_path = project_path .. path_sep .. unique_filename table.insert(jobs, { text = prompt_text, filename = unique_filename, outputFile = output_file_path, from_notes = false, prompt_id = prompt_id }) end end if #jobs == 0 then reaper.ShowMessageBox("No valid prompts to generate.", "Info", 0) return end execute_batch_generation(jobs, track) end function generate_from_selected_items() local selected_items_count = reaper.CountSelectedMediaItems(0) if selected_items_count == 0 then reaper.ShowMessageBox("No items selected.", "Error", 0) return end local dest_track = get_destination_track() if not dest_track then reaper.ShowMessageBox("No destination track selected or available. Please select a track to place the audio on.", "Error", 0) return end local project_path = reaper.GetProjectPath("") if project_path == "" then reaper.ShowMessageBox("Please save the project first.", "Error", 0) return end local iterations = tonumber(number_of_iterations) if not iterations or iterations < 1 then iterations = 1 end local jobs = {} local job_counter = 1 for i = 0, selected_items_count - 1 do local item = reaper.GetSelectedMediaItem(0, i) local note = reaper.ULT_GetMediaItemNote(item) if note and note:match("%S") then local position = reaper.GetMediaItemInfo_Value(item, "D_POSITION") local prompt_id = "item_prompt_" .. i for j = 1, iterations do local unique_filename = generate_unique_filename(note, job_counter) local output_file_path = project_path .. path_sep .. unique_filename table.insert(jobs, { text = note, position = position, filename = unique_filename, outputFile = output_file_path, from_notes = true, prompt_id = prompt_id }) job_counter = job_counter + 1 end end end if #jobs == 0 then reaper.ShowMessageBox("None of the selected items have notes.", "Info", 0) return end execute_batch_generation(jobs, dest_track) end function loop() reaper.ImGui_SetNextWindowSize(reaper_imgui, 500, 200, reaper.ImGui_Cond_FirstUseEver()) local is_visible, is_open = reaper.ImGui_Begin(reaper_imgui, "ElevenLabs Sound Effects", true) if is_visible then reaper.ImGui_Text(reaper_imgui, "Describe the sound effect you want to create:") reaper.ImGui_TextDisabled(reaper_imgui, "(For sequences, separate prompts with '|' and click 'Generate Sequence')") local presets_for_combo = "Select a preset...\0" .. table.concat(prompt_presets, "\0") .. "\0" local preset_changed, new_preset_idx = reaper.ImGui_Combo(reaper_imgui, "##Presets", selected_preset_idx, presets_for_combo) if preset_changed and new_preset_idx > 0 then selected_preset_idx = new_preset_idx input_text = prompt_presets[selected_preset_idx] end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Save Preset") then if input_text and input_text:match("%S") then local exists = false for _, p in ipairs(prompt_presets) do if p == input_text then exists = true; break end end if not exists then table.insert(prompt_presets, input_text) save_presets() reaper.ShowConsoleMsg("Preset saved: " .. input_text .. "\n") else reaper.ShowMessageBox("This preset already exists.", "Info", 0) end end end local changed, new_text = reaper.ImGui_InputTextMultiline(reaper_imgui, "##input_text", input_text, 8192, -1, -90, 0, nil) if changed then input_text = new_text end if is_processing then reaper.ImGui_TextDisabled(reaper_imgui, "Processing... Please wait.") else if reaper.ImGui_Button(reaper_imgui, "Generate") then generate_from_textbox(false) end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Generate Sequence") then generate_from_textbox(true) end if reaper.ImGui_Button(reaper_imgui, "Generate from Selected Note(s)") then generate_from_selected_items() end end if reaper.ImGui_Button(reaper_imgui, "Settings") then reaper.ImGui_OpenPopup(reaper_imgui, "Settings") end if reaper.ImGui_BeginPopupModal(reaper_imgui, "Settings", nil, reaper.ImGui_WindowFlags_AlwaysAutoResize()) then reaper.ImGui_Text(reaper_imgui, "API Keys (comma-separated):") local api_keys_changed, new_api_keys = reaper.ImGui_InputText(reaper_imgui, "##apikeys", api_keys_string, 4096) if api_keys_changed then api_keys_string = new_api_keys end reaper.ImGui_Separator(reaper_imgui) reaper.ImGui_Text(reaper_imgui, "Sound Effect Settings") reaper.ImGui_Text(reaper_imgui, "Duration (seconds):") local duration_changed, new_duration = reaper.ImGui_InputText(reaper_imgui, "##duration", duration_seconds, 128) if duration_changed then duration_seconds = new_duration end reaper.ImGui_Text(reaper_imgui, "Prompt Influence:") local influence_changed, new_influence = reaper.ImGui_InputText(reaper_imgui, "##influence", prompt_influence, 128) if influence_changed then prompt_influence = new_influence end reaper.ImGui_SameLine(reaper_imgui) reaper.ImGui_TextDisabled(reaper_imgui, "(0.0 to 1.0)") reaper.ImGui_Separator(reaper_imgui) reaper.ImGui_Text(reaper_imgui, "Number of Variations:") local iterations_changed, new_iterations = reaper.ImGui_InputText(reaper_imgui, "##iterations", number_of_iterations, 8) if iterations_changed then if new_iterations:match("^[1-9]%d*$") or new_iterations == "" then number_of_iterations = new_iterations end end reaper.ImGui_SameLine(reaper_imgui) reaper.ImGui_TextDisabled(reaper_imgui, "(e.g., 3 for 3 versions)") reaper.ImGui_Separator(reaper_imgui) local takes_changed, new_takes_val = reaper.ImGui_Checkbox(reaper_imgui, "Generate as New Takes", generate_as_takes) if takes_changed then generate_as_takes = new_takes_val end reaper.ImGui_Separator(reaper_imgui) reaper.ImGui_Text(reaper_imgui, "Insertion Position:") reaper.ImGui_Indent(reaper_imgui) if reaper.ImGui_RadioButton(reaper_imgui, "Sequential on selected track", insertion_mode == 1) then insertion_mode = 1 end reaper.ImGui_SameLine(reaper_imgui) reaper.ImGui_TextDisabled(reaper_imgui, "(Default)") if reaper.ImGui_RadioButton(reaper_imgui, "At original item position (from Notes)", insertion_mode == 2) then insertion_mode = 2 end if reaper.ImGui_RadioButton(reaper_imgui, "Sequential on a new track", insertion_mode == 3) then insertion_mode = 3 end reaper.ImGui_Unindent(reaper_imgui) reaper.ImGui_Separator(reaper_imgui) reaper.ImGui_Text(reaper_imgui, "Manage Presets") if reaper.ImGui_Button(reaper_imgui, "Manage Presets...") then open_preset_manager_popup = true reaper.ImGui_CloseCurrentPopup(reaper_imgui) end reaper.ImGui_Separator(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Save & Close", -1, 25) then save_settings() reaper.ImGui_CloseCurrentPopup(reaper_imgui) end reaper.ImGui_EndPopup(reaper_imgui) end reaper.ImGui_End(reaper_imgui) end if open_preset_manager_popup then reaper.ImGui_OpenPopup(reaper_imgui, "Preset Manager") open_preset_manager_popup = false end if reaper.ImGui_BeginPopupModal(reaper_imgui, "Preset Manager", nil, reaper.ImGui_WindowFlags_AlwaysAutoResize()) then reaper.ImGui_Text(reaper_imgui, "Filter:") reaper.ImGui_SameLine(reaper_imgui) local filter_changed, new_filter = reaper.ImGui_InputText(reaper_imgui, "##filter", preset_filter_text, 256) if filter_changed then preset_filter_text = new_filter end reaper.ImGui_Separator(reaper_imgui) local filtered_presets = {} local filtered_presets_map = {} for i, preset in ipairs(prompt_presets) do if preset:lower():find(preset_filter_text:lower(), 1, true) then table.insert(filtered_presets, preset) filtered_presets_map[#filtered_presets] = i end end reaper.ImGui_BeginChild(reaper_imgui, "##presetlistbox", -1, 200, 1, 0) for i, preset in ipairs(filtered_presets) do local is_selected = (listbox_selected_idx == (i - 1)) if reaper.ImGui_Selectable(reaper_imgui, preset, is_selected) then listbox_selected_idx = i - 1 end end reaper.ImGui_EndChild(reaper_imgui) local original_idx = filtered_presets_map[listbox_selected_idx + 1] if reaper.ImGui_Button(reaper_imgui, "Load") and original_idx then input_text = prompt_presets[original_idx] reaper.ImGui_CloseCurrentPopup(reaper_imgui) end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Rename") and original_idx then preset_to_rename_idx = original_idx rename_buffer = prompt_presets[original_idx] reaper.ImGui_OpenPopup(reaper_imgui, "Rename Preset") end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Delete") and original_idx then table.remove(prompt_presets, original_idx) save_presets() listbox_selected_idx = -1 end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Close") then reaper.ImGui_CloseCurrentPopup(reaper_imgui) end if reaper.ImGui_BeginPopupModal(reaper_imgui, "Rename Preset", nil, reaper.ImGui_WindowFlags_AlwaysAutoResize()) then reaper.ImGui_Text(reaper_imgui, "Enter new name:") local rename_changed, new_rename = reaper.ImGui_InputText(reaper_imgui, "##renamebuffer", rename_buffer, 8192) if rename_changed then rename_buffer = new_rename end if reaper.ImGui_Button(reaper_imgui, "OK") then if rename_buffer and rename_buffer:match("%S") and preset_to_rename_idx > 0 then prompt_presets[preset_to_rename_idx] = rename_buffer save_presets() end reaper.ImGui_CloseCurrentPopup(reaper_imgui) end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Cancel") then reaper.ImGui_CloseCurrentPopup(reaper_imgui) end reaper.ImGui_EndPopup(reaper_imgui) end reaper.ImGui_EndPopup(reaper_imgui) end if is_open then reaper.defer(loop) else save_settings() end end load_settings() load_presets() loop()
