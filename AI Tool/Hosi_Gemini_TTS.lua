--[[
@description Google Gemini TTS (Item Note Version)
@version 2.1
@author Hosi
@about
  - Helper script to generate TTS from an item's note using Google's Gemini TTS API.
  - Supports batch processing, model selection, and style instructions.
  - Quick Presets for Style Instructions.
@changelog
  + v2.1 (2025-07-14)
    - FIXED: Script crashing when generated audio item overlaps with the source text item.
    - Used pcall for safer API calls during item detection loop.
  + v2.0 (2025-07-08)
    - ADDED: Quick Presets for Style Instructions.
    - Improved interface, fixed bugs and increased stability.
  + v1.0 (2025-07-06)
    - Initial release.
@reaper_version 7.0
@depends ReaTeam Extensions/API/reaper_imgui.ext
--]]
--[[
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * !! IMPORTANT / QUAN TRỌNG                                                !!
 * !!                                                                       !!
 * !! This file MUST be saved with UTF-8 encoding for Unicode characters    !!
 * !! (like Vietnamese) to work correctly.                                  !!
 * !!                                                                       !!
 * !! File này BẮT BUỘC phải được lưu với định dạng mã hóa UTF-8 để các      !!
 * !! ký tự Unicode (như tiếng Việt) có thể hoạt động chính xác.             !!
 * !!                                                                       !!
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--]]
if not reaper.ImGui_CreateContext then reaper.ShowMessageBox("This script requires the ReaImGui extension.\n\nPlease install it from ReaPack (under the 'Extensions' section) and restart REAPER.", "Error: ReaImGui Not Found", 0) return end reaper.ClearConsole() local reaper_imgui = reaper.ImGui_CreateContext("Gemini TTS") local settings_file = reaper.GetResourcePath() .. '/gemini_tts_simple.txt' local api_keys_string = "" local style_instructions_text = "Read aloud in a warm and friendly tone" local voices = { "Kore", "Zephyr", "Puck", "Charon", "Fenrir", "Leda", "Orus", "Aoede", "Callirrhoe", "Autonoe", "Enceladus", "lapetus", "Umbriel", "Algieba", "Despina", "Erinome", "Algenib", "Rasalgethi", "Laomedeia", "Alnilam", "Schedar", "Gacrux", "Pulcherrima", "Achird", "Zubenelgenubi", "Vindemiatrix", "Sadachbia", "Sulafast" } local voices_string = table.concat(voices, "\0") .. "\0" local current_voice_index = 1 local models = { "gemini-2.5-pro-preview-tts", "gemini-2.5-flash-preview-tts", "gemini-1.5-flash-tts" } local models_string = table.concat(models, "\0") .. "\0" local current_model_index = 1 function string.split(inputstr, sep) if sep == nil then sep = "%s" end local t={} for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do table.insert(t, str:match("^%s*(.-)%s*$")) end return t end function load_settings() local file = io.open(settings_file, "r") if file then local content = file:read("*all") file:close() if content and content ~= "" then local lines = {} for line in content:gmatch("[^\r\n]+") do table.insert(lines, line) end if #lines >= 4 then current_voice_index = 1 for i, v in ipairs(voices) do if v == lines[1] then current_voice_index = i break end end current_model_index = tonumber(lines[2]) or 1 style_instructions_text = lines[3] or "Read aloud in a warm and friendly tone" api_keys_string = lines[4] or "" api_keys_string = api_keys_string:gsub("[%c]", ""):gsub("%s+", " "):match("^%s*(.-)%s*$") or "" end end end end function save_settings() local clean_keys = api_keys_string:gsub("[%c]", ""):gsub("%s+", " "):match("^%s*(.-)%s*$") or "" local file = io.open(settings_file, "w") if file then file:write(voices[current_voice_index] .. "\n") file:write(tostring(current_model_index) .. "\n") file:write(style_instructions_text .. "\n") file:write(clean_keys .. "\n") file:close() api_keys_string = clean_keys end end function escape_json_text(text) local result = text:gsub('\\', '\\\\'):gsub('"', '\\"'):gsub("\n", "\\n"):gsub("\r", "\\r"):gsub("\t", "\\t"):gsub("/", "\\/"):gsub("[\b\f]", function(c) return string.format("\\%s", c) end):gsub("[%z\1-\31]", function(c) return string.format("\\u%04x", string.byte(c)) end) return result end function generate_unique_filename(text) local timestamp = os.date("%Y%m%d_%H%M%S") local words = {} for word in text:gmatch("%S+") do table.insert(words, word) if #words >= 2 then break end end local abbreviation = table.concat(words, "_"):gsub("[^%w_]", "") return "TTS_" .. timestamp .. "_" .. abbreviation .. ".wav" end function set_item_note_to_text(item, note) reaper.ULT_SetMediaItemNote(item, note) end function set_item_name_with_suffix(item, base_name, suffix) local take = reaper.GetActiveTake(item) if take then local new_name = base_name:gsub("%.wav$", "") .. suffix reaper.GetSetMediaItemTakeInfo_String(take, "P_NAME", new_name, true) end end function generate_single_audio_file(text, output_path) if not text or text == "" then reaper.ShowMessageBox("Text is empty.", "Info", 0) return nil end local keys_to_try = string.split(api_keys_string, ",") if #keys_to_try == 0 or (#keys_to_try == 1 and keys_to_try[1] == "") then reaper.ShowMessageBox("No API Keys found. Please add keys in Settings.", "Error", 0) return nil end local final_text = style_instructions_text .. " " .. text local escaped_text = escape_json_text(final_text) local voice_name = voices[current_voice_index] local model_name = models[current_model_index] for i, current_api_key in ipairs(keys_to_try) do local clean_key = current_api_key:match("^%s*(.-)%s*$") if not clean_key or #clean_key < 20 then goto continue end local speech_config_json = string.format('{"voiceConfig":{"prebuiltVoiceConfig":{"voiceName":"%s"}}}', voice_name) local json_body = string.format('{"contents": [{"parts":[{"text": "%s"}]}],"generationConfig": {"responseModalities": ["AUDIO"],"speechConfig": %s},"model": "%s"}', escaped_text, speech_config_json, model_name) local ps_script = reaper.GetResourcePath() .. '/temp_tts.ps1' local ps_content = string.format([[ $ErrorActionPreference = 'Stop' try { $response = Invoke-RestMethod -Uri 'https://generativelanguage.googleapis.com/v1beta/models/%s:generateContent?key=%s' -Method Post -Body @' %s '@ -ContentType 'application/json' $audioData = $response.candidates[0].content.parts[0].inlineData.data $audioBytes = [Convert]::FromBase64String($audioData) [IO.File]::WriteAllBytes('%s.tmp', $audioBytes) ffmpeg -y -f s16le -ar 24000 -ac 1 -i '%s.tmp' '%s' Remove-Item '%s.tmp' -ErrorAction SilentlyContinue Write-Host 'Success' } catch { Write-Host ('Error: ' + $_.Exception.Message) exit 1 } ]], model_name, clean_key, json_body, output_path, output_path, output_path, output_path) local file = io.open(ps_script, "w") if file then file:write(ps_content) file:close() local command = string.format('powershell -WindowStyle Hidden -NoProfile -File "%s"', ps_script) local result = io.popen(command):read("*a") os.remove(ps_script) if result:match("Success") then return reaper.file_exists(output_path) and output_path or nil end end ::continue:: end return nil end function start_generation() local selected_items_count = reaper.CountSelectedMediaItems(0) if selected_items_count == 0 then reaper.ShowMessageBox("No items selected.", "Error", 0) return end local items_to_process = {} for i = 0, selected_items_count - 1 do local item = reaper.GetSelectedMediaItem(0, i) local note = reaper.ULT_GetMediaItemNote(item) if note and note ~= "" then local position = reaper.GetMediaItemInfo_Value(item, "D_POSITION") table.insert(items_to_process, {item=item, note=note, position=position}) end end if #items_to_process == 0 then reaper.ShowMessageBox("None of the selected items have notes.", "Info", 0) return end table.sort(items_to_process, function(a, b) return a.position < b.position end) local track = reaper.GetMediaItem_Track(items_to_process[1].item) if not track then track = reaper.GetSelectedTrack(0, 0) end if not track then reaper.ShowMessageBox("Could not determine a track to place the audio on.", "Error", 0) return end reaper.Undo_BeginBlock() for _, data in ipairs(items_to_process) do local note = data.note local insert_pos = data.position local project_path = reaper.GetProjectPath("") if project_path == "" then reaper.ShowMessageBox("Please save the project first.", "Error", 0) reaper.Undo_EndBlock("Generate TTS (project not saved)", -1) return end local filename = generate_unique_filename(note) local output_path = project_path .. "\\" .. filename local generated_filepath = generate_single_audio_file(note, output_path) if generated_filepath then reaper.SetEditCurPos(insert_pos, false, false) reaper.InsertMedia(generated_filepath, 0) reaper.UpdateArrange() local new_item = nil local num_items_on_track = reaper.CountTrackMediaItems(track) for j = 0, num_items_on_track - 1 do local current_item = reaper.GetTrackMediaItem(track, j) if current_item then local take = reaper.GetActiveTake(current_item) if take then local success, source = pcall(reaper.GetMediaSourceFromTake, take) if success and source then local type_success, source_type = pcall(reaper.GetMediaSourceType, source) if type_success and source_type and source_type:find("WAV") then local name_success, _, file_path = pcall(reaper.GetMediaSourceFileName, source, "") if name_success and file_path then if file_path:gsub("\\", "/") == generated_filepath:gsub("\\", "/") then new_item = current_item break end end end end end end end end if new_item then reaper.SetMediaItemInfo_Value(new_item, "D_POSITION", insert_pos) set_item_note_to_text(new_item, note) set_item_name_with_suffix(new_item, filename, string.format(" [%s]", voices[current_voice_index])) end end end reaper.Undo_EndBlock("Generate TTS", 0) end function loop() reaper.ImGui_SetNextWindowSize(reaper_imgui, 340, 300, reaper.ImGui_Cond_FirstUseEver()) local visible, open = reaper.ImGui_Begin(reaper_imgui, "Gemini TTS", true) if visible then reaper.ImGui_TextWrapped(reaper_imgui, "TTS from item notes") reaper.ImGui_Separator(reaper_imgui) reaper.ImGui_Text(reaper_imgui, "Model:") reaper.ImGui_SameLine(reaper_imgui, 60) reaper.ImGui_PushItemWidth(reaper_imgui, -1) local model_changed, new_model = reaper.ImGui_Combo(reaper_imgui, "##model", current_model_index - 1, models_string) if model_changed then current_model_index = new_model + 1 end reaper.ImGui_PopItemWidth(reaper_imgui) reaper.ImGui_Text(reaper_imgui, "Voice:") reaper.ImGui_SameLine(reaper_imgui, 60) reaper.ImGui_PushItemWidth(reaper_imgui, -80) local voice_changed, new_voice = reaper.ImGui_Combo(reaper_imgui, "##voice", current_voice_index - 1, voices_string) if voice_changed then current_voice_index = new_voice + 1 end reaper.ImGui_PopItemWidth(reaper_imgui) reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Test", 70, 0) then os.execute('start "" "https://aistudio.google.com/u/0/generate-speech"') end reaper.ImGui_Separator(reaper_imgui) reaper.ImGui_Text(reaper_imgui, "Quick Presets:") if reaper.ImGui_Button(reaper_imgui, "Professional", 80, 0) then style_instructions_text = "Read in a calm, steady, and professional tone with consistent pacing" end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Friendly", 80, 0) then style_instructions_text = "Read aloud in a warm and friendly tone" end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Dynamic", 80, 0) then style_instructions_text = "Read with enthusiasm, varying pace and emotional expression" end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Clear", 60, 0) then style_instructions_text = "" end reaper.ImGui_Text(reaper_imgui, "Style Instructions:") reaper.ImGui_PushItemWidth(reaper_imgui, -1) local style_changed, new_style = reaper.ImGui_InputText(reaper_imgui, "##style", style_instructions_text, 1024, 0, nil) if style_changed then style_instructions_text = new_style end reaper.ImGui_PopItemWidth(reaper_imgui) reaper.ImGui_TextColored(reaper_imgui, 0x00FF00FF, "Always editable - click and type") reaper.ImGui_Separator(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Generate TTS", -80, 30) then start_generation() end reaper.ImGui_SameLine(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Settings", 70, 30) then reaper.ImGui_OpenPopup(reaper_imgui, "API Settings") end if reaper.ImGui_BeginPopupModal(reaper_imgui, "API Settings", nil, reaper.ImGui_WindowFlags_AlwaysAutoResize()) then reaper.ImGui_Text(reaper_imgui, "API Keys (comma-separated):") reaper.ImGui_Spacing(reaper_imgui) reaper.ImGui_PushItemWidth(reaper_imgui, 500) local temp_keys = api_keys_string or "" local keys_changed, new_keys = reaper.ImGui_InputText(reaper_imgui, "##keys", temp_keys, 4096) if keys_changed then local cleaned = new_keys:gsub("[%c]", ""):gsub("%s+", " "):match("^%s*(.-)%s*$") or "" api_keys_string = cleaned end reaper.ImGui_PopItemWidth(reaper_imgui) local keys = string.split(api_keys_string, ",") local valid_count = 0 for _, key in ipairs(keys) do if key and #key > 20 then valid_count = valid_count + 1 end end reaper.ImGui_Spacing(reaper_imgui) reaper.ImGui_Text(reaper_imgui, string.format("Valid keys: %d", valid_count)) if valid_count == 0 then reaper.ImGui_TextColored(reaper_imgui, 0xFF0000FF, "No valid keys!") else reaper.ImGui_TextColored(reaper_imgui, 0x00FF00FF, "Keys OK!") end reaper.ImGui_Spacing(reaper_imgui) if reaper.ImGui_Button(reaper_imgui, "Save & Close", -1, 0) then save_settings() reaper.ImGui_CloseCurrentPopup(reaper_imgui) end reaper.ImGui_EndPopup(reaper_imgui) end reaper.ImGui_End(reaper_imgui) end if not open then return end reaper.defer(loop) end load_settings() loop()
